---
phase: 02-audio-engine
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/AudioService.ts
autonomous: true
requirements: [AUDIO-01, AUDIO-02]

must_haves:
  truths:
    - "A single AudioService instance exists for the module lifetime — never re-created on navigation"
    - "Calling AudioService.play(soundId, localUri) starts audio immediately (auto-play, no extra UI step)"
    - "Audio continues playing when the screen locks on iOS and when the user switches apps on Android"
    - "Switching to a new sound crossfades: old player fades out while new player fades in over 700ms, then old player is released"
    - "Tapping the active sound (toggle off) stops playback instantly with no fade"
    - "AudioService exposes a stop() method that cuts audio immediately"
  artifacts:
    - path: "src/services/AudioService.ts"
      provides: "Singleton audio engine: play, stop, crossfade, setAudioModeAsync background config"
      exports: ["AudioService"]
      min_lines: 80
  key_links:
    - from: "src/services/AudioService.ts"
      to: "expo-audio createAudioPlayer"
      via: "import { createAudioPlayer } from 'expo-audio'"
      pattern: "createAudioPlayer"
    - from: "src/services/AudioService.ts"
      to: "AudioService.initialize()"
      via: "called once in app/_layout.tsx on mount"
      pattern: "setAudioModeAsync"
---

<objective>
Build the AudioService singleton that powers all audio playback in the app. This service wraps expo-audio's `createAudioPlayer` API, configures the audio session for background playback and silent-mode bypass, implements crossfade switching (LOCKED: 700ms, old fades out while new fades in), and exposes a clean play/stop interface to the rest of the app.

Purpose: Phase 2's goal is audio you can hear — this is the engine. All UI in Phase 3 calls into AudioService. Getting this right now (background audio, crossfade, no memory leaks from player.remove()) prevents rework in every subsequent phase.

Output: `src/services/AudioService.ts` — module-level singleton class with initialize(), play(), stop(), and internal crossfade logic.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-engine/02-RESEARCH.md
@.planning/phases/02-audio-engine/02-CONTEXT.md
@src/stores/audioStore.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install expo-audio and configure audio session</name>
  <files>
    package.json
  </files>
  <action>
Install expo-audio ~1.1.1. Do NOT install expo-av — it is deprecated in SDK 54 and removed in SDK 55. expo-audio is the correct library per research.

```bash
npx expo install expo-audio
```

After install, verify expo-audio appears in package.json dependencies. No additional native config is needed — UIBackgroundModes is already set in app.json from Phase 1.
  </action>
  <verify>
```bash
# Confirm expo-audio is installed
grep "expo-audio" package.json
# Expected: "expo-audio": "~1.x.x"

# Confirm expo-av is NOT present (deprecated)
grep "expo-av" package.json && echo "ERROR: expo-av should not be installed" || echo "OK: expo-av absent"
```
  </verify>
  <done>
- `expo-audio` appears in package.json dependencies at ~1.x.x
- `expo-av` does not appear in package.json
  </done>
</task>

<task type="auto">
  <name>Task 2: AudioService singleton with background audio and crossfade</name>
  <files>
    src/services/AudioService.ts
  </files>
  <action>
Create `src/services/AudioService.ts`. This is a class-based singleton (not a React hook) so it survives navigation and can be imported anywhere.

**Critical architecture rules from research:**
- Use `createAudioPlayer(source)` NOT `useAudioPlayer` hook — the hook is React-lifecycle-bound and dies on unmount
- `initialize()` must be called ONCE at app startup (in app/_layout.tsx). Call `setAudioModeAsync` there.
- For crossfade: toggle `interruptionMode` to `'mixWithOthers'` during the fade window, then back to `'doNotMix'` after so lock screen controls work correctly
- Call `player.remove()` on the outgoing player after crossfade completes — failure to do this leaks memory
- LOCKED decisions to implement exactly:
  - Switching sounds: crossfade 700ms (old fades out, new fades in simultaneously)
  - Toggle off (tapping active sound): instant stop, NO fade
  - Sounds always loop (player.loop = true)

```typescript
// src/services/AudioService.ts
//
// Module-level singleton. Import AudioService anywhere — it is the same instance.
// Call AudioService.initialize() once in app/_layout.tsx.
// Do NOT use useAudioPlayer hook — it is lifecycle-bound to React components.

import { createAudioPlayer, setAudioModeAsync, AudioPlayer } from 'expo-audio';

const CROSSFADE_DURATION_MS = 700; // LOCKED per user decision

class AudioServiceClass {
  private activePlayer: AudioPlayer | null = null;
  private activeSoundId: string | null = null;
  private crossfadeTimer: ReturnType<typeof setTimeout> | null = null;

  /**
   * Call once at app startup in app/_layout.tsx.
   * Configures the audio session: background audio + silent mode bypass.
   *
   * interruptionMode 'doNotMix': when audio is playing, other apps' audio is ducked.
   * This is the correct default for a dedicated audio player app.
   * It is temporarily switched to 'mixWithOthers' during crossfades only.
   *
   * playsInSilentMode: true — CRITICAL for iOS silent switch compliance.
   * staysActiveInBackground: true — CRITICAL for lock screen / background audio.
   */
  async initialize(): Promise<void> {
    await setAudioModeAsync({
      playsInSilentModeIOS: true,
      staysActiveInBackground: true,
      interruptionModeIOS: 'doNotMix',
      interruptionModeAndroid: 'doNotMix',
      shouldDuckAndroid: false,
    });
  }

  /**
   * Play a sound by ID. Accepts the local file:// URI (from SoundCacheService).
   *
   * Behavior:
   * - If soundId === activeSoundId → toggle off (instant stop, no fade)
   * - If a different sound is playing → crossfade
   * - If nothing is playing → start immediately at full volume
   */
  async play(soundId: string, localUri: string): Promise<void> {
    // Toggle off: tapping active sound stops instantly (LOCKED — no fade on manual stop)
    if (this.activeSoundId === soundId) {
      this.stop();
      return;
    }

    if (this.activePlayer) {
      // Crossfade: new sound starts simultaneously with old fading out (LOCKED)
      await this._crossfadeTo(localUri, soundId);
    } else {
      // Fresh start — nothing playing
      await this._startFresh(localUri, soundId);
    }
  }

  /**
   * Instant stop. No fade. Used for: toggle off, timer expiry (after fade-out in TimerService),
   * and explicit stop calls.
   */
  stop(): void {
    if (this.crossfadeTimer) {
      clearTimeout(this.crossfadeTimer);
      this.crossfadeTimer = null;
    }
    if (this.activePlayer) {
      this.activePlayer.remove();
      this.activePlayer = null;
    }
    this.activeSoundId = null;
  }

  /**
   * Fade out the currently active player over durationMs.
   * Used by TimerService for the "timer reached zero" fade-out.
   * Does NOT stop — TimerService calls stop() after the fade completes.
   */
  async fadeOut(durationMs: number): Promise<void> {
    if (!this.activePlayer) return;
    const player = this.activePlayer;
    const steps = 20;
    const stepMs = durationMs / steps;
    const startVolume = player.volume;

    for (let i = 1; i <= steps; i++) {
      await new Promise<void>((resolve) => setTimeout(resolve, stepMs));
      player.volume = startVolume * (1 - i / steps);
    }
  }

  getActiveSoundId(): string | null {
    return this.activeSoundId;
  }

  isPlaying(): boolean {
    return this.activePlayer !== null && this.activePlayer.playing;
  }

  // ─── Private ────────────────────────────────────────────────────────────────

  private async _startFresh(localUri: string, soundId: string): Promise<void> {
    const player = createAudioPlayer({ uri: localUri });
    player.loop = true;  // Sounds always loop (LOCKED — loop is always on)
    player.volume = 1.0;
    player.play();

    this.activePlayer = player;
    this.activeSoundId = soundId;
  }

  private async _crossfadeTo(newUri: string, newSoundId: string): Promise<void> {
    const outgoing = this.activePlayer!;

    // Switch to mixWithOthers so both players can run simultaneously during the crossfade
    await setAudioModeAsync({ interruptionModeIOS: 'mixWithOthers', interruptionModeAndroid: 'mixWithOthers' });

    // Start incoming player at volume 0
    const incoming = createAudioPlayer({ uri: newUri });
    incoming.loop = true;  // Always loop (LOCKED)
    incoming.volume = 0;
    incoming.play();

    // Simultaneously fade out outgoing and fade in incoming
    const steps = 20;
    const stepMs = CROSSFADE_DURATION_MS / steps;
    const outgoingStartVolume = outgoing.volume;

    for (let i = 1; i <= steps; i++) {
      await new Promise<void>((resolve) => setTimeout(resolve, stepMs));
      outgoing.volume = outgoingStartVolume * (1 - i / steps);
      incoming.volume = 1.0 * (i / steps);
    }

    // Release outgoing player — CRITICAL to prevent memory leak
    outgoing.remove();

    // Restore doNotMix so lock screen controls work correctly
    await setAudioModeAsync({ interruptionModeIOS: 'doNotMix', interruptionModeAndroid: 'doNotMix' });

    this.activePlayer = incoming;
    this.activeSoundId = newSoundId;
  }
}

// Module-level singleton — same instance across all imports
export const AudioService = new AudioServiceClass();
```

**Note on `setAudioModeAsync` import:** In expo-audio ~1.1.1, `setAudioModeAsync` is a named export from `'expo-audio'`. If TypeScript reports it missing, check the exact export name in node_modules/expo-audio/build/index.d.ts and adjust the import accordingly (it may be `AudioModule.setAudioModeAsync` or similar). Document any deviation in a comment.
  </action>
  <verify>
```bash
# TypeScript check — must pass with 0 errors
npx tsc --noEmit

# Verify createAudioPlayer import (not useAudioPlayer hook)
grep "createAudioPlayer" src/services/AudioService.ts

# Verify loop is always true (LOCKED decision)
grep "player.loop = true" src/services/AudioService.ts

# Verify CROSSFADE_DURATION_MS = 700
grep "CROSSFADE_DURATION_MS = 700" src/services/AudioService.ts

# Verify player.remove() is called on outgoing player (memory leak prevention)
grep "outgoing.remove()" src/services/AudioService.ts

# Verify playsInSilentModeIOS and staysActiveInBackground in initialize()
grep "playsInSilentModeIOS: true" src/services/AudioService.ts
grep "staysActiveInBackground: true" src/services/AudioService.ts

# Verify module-level singleton export
grep "export const AudioService = new AudioServiceClass" src/services/AudioService.ts
```
  </verify>
  <done>
- `src/services/AudioService.ts` exists and exports `AudioService` as a module-level singleton
- `initialize()` calls `setAudioModeAsync` with `playsInSilentModeIOS: true` and `staysActiveInBackground: true`
- `play(soundId, localUri)` toggles off (instant) when same soundId, crossfades when different, starts fresh when nothing playing
- `stop()` cuts audio immediately with no fade and calls `player.remove()`
- `fadeOut(durationMs)` animates volume from current to 0 (used by TimerService)
- All players created with `loop = true` (sounds always loop)
- Crossfade uses 700ms with `interruptionMode` toggled to `mixWithOthers` during fade, restored after
- `npx tsc --noEmit` passes with 0 errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
# Full TypeScript check
npx tsc --noEmit
# Expected: 0 errors

# Verify expo-audio installed, expo-av absent
grep "expo-audio" package.json
grep "expo-av" package.json && echo "ERROR" || echo "OK"

# Verify AudioService singleton
grep "export const AudioService = new AudioServiceClass" src/services/AudioService.ts

# Verify background audio config
grep -A 5 "initialize" src/services/AudioService.ts | grep "staysActiveInBackground"

# Verify crossfade duration locked at 700ms
grep "CROSSFADE_DURATION_MS = 700" src/services/AudioService.ts

# Verify memory leak prevention
grep "outgoing.remove()" src/services/AudioService.ts
```
</verification>

<success_criteria>
- expo-audio ~1.x.x is installed and expo-av is not present
- `src/services/AudioService.ts` exports a module-level singleton `AudioService`
- `initialize()` configures background audio with playsInSilentModeIOS + staysActiveInBackground
- `play(soundId, localUri)` implements three behaviors: toggle-off (instant), crossfade (700ms), fresh start
- `stop()` immediately releases the active player with no fade
- `fadeOut(durationMs)` animates volume to 0 (for TimerService use)
- All players set `loop = true`
- `npx tsc --noEmit` reports 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-audio-engine/02-01-SUMMARY.md` following the summary template.
</output>
