---
phase: 06-freemium-and-monetization
plan: 03
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - src/stores/audioStore.ts
  - src/services/TimerService.ts
  - app/player.tsx
autonomous: true
requirements:
  - AUDIO-05
  - AUDIO-06

must_haves:
  truths:
    - "Infinity mode toggle is visible in the player screen; tapping it activates infinite looping for premium users"
    - "Free users tapping the Infinity mode toggle are routed to the paywall instead of activating Infinity mode"
    - "Custom timer duration input is visible in the player screen; premium users can enter any duration in minutes"
    - "Free users tapping the custom timer input see the paywall instead of a duration picker"
    - "Infinity mode and custom timer duration unlock immediately after purchase with no app restart"
    - "When Infinity mode is active, no timer countdown starts — audio plays indefinitely until stopped by the user"
    - "Custom timer duration, when set, replaces the default timer selection for the current session"
  artifacts:
    - path: "src/stores/audioStore.ts"
      provides: "timerMode field ('countdown' | 'infinity'); customTimerSeconds: number | null; setTimerMode; setCustomTimerSeconds actions"
      contains: "timerMode"
    - path: "app/player.tsx"
      provides: "Infinity mode toggle UI (premium gated); custom timer duration input UI (premium gated); both call openPaywall() for free users"
      contains: "openPaywall"
  key_links:
    - from: "app/player.tsx"
      to: "src/stores/audioStore.ts"
      via: "setTimerMode('infinity') when Infinity mode activated; setCustomTimerSeconds(seconds) when custom duration set"
      pattern: "setTimerMode"
    - from: "app/player.tsx"
      to: "src/services/PremiumPaywallService.ts"
      via: "openPaywall() called when free user taps Infinity mode or custom timer"
      pattern: "openPaywall"
    - from: "app/player.tsx"
      to: "src/stores/authStore.ts"
      via: "useAuthStore(s => s.isPremium) gates Infinity mode and custom timer controls"
      pattern: "isPremium"
    - from: "src/services/TimerService.ts"
      to: "src/stores/audioStore.ts"
      via: "TimerService.start() reads timerMode (infinity guard) and customTimerSeconds (duration override) from useAudioStore.getState() before starting countdown"
      pattern: "timerMode|customTimerSeconds"
---

<objective>
Add Infinity mode (AUDIO-05) and custom timer duration (AUDIO-06) to the player screen, both gated behind authStore.isPremium. Extend audioStore with timerMode and customTimerSeconds fields. Free users tapping either control see the paywall. Premium users can activate Infinity mode or set any timer duration.

Purpose: Plan 06-01 provides the isPremium signal. This plan adds the two premium audio features that the ROADMAP requires. Both are pure client-side UI gates — no audio engine changes needed. Infinity mode = no timer countdown; custom timer = user-chosen duration replaces default timer selection.

Output: Infinity mode toggle and custom timer input in the player screen, both wired to isPremium from authStore with paywall routing for free users.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-freemium-and-monetization/06-RESEARCH.md
@.planning/phases/06-freemium-and-monetization/06-01-SUMMARY.md
@src/stores/audioStore.ts
@app/player.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend audioStore with timerMode and customTimerSeconds, add Infinity mode + custom timer UI to player</name>
  <files>
    src/stores/audioStore.ts
    app/player.tsx
  </files>
  <action>
**Step 1 — Extend src/stores/audioStore.ts:**

Read the current `src/stores/audioStore.ts`. It was scaffolded in Phase 1 and extended in Phase 2 (timer timestamp fields for `TimerService`) and Phase 3 (player UI). Read the actual current state before editing.

Add two new fields and their setters — do not remove or rename existing fields:

```typescript
// ADD to AudioState interface:
timerMode: 'countdown' | 'infinity'; // 'countdown' = default timer; 'infinity' = no time limit
customTimerSeconds: number | null;   // null = not set; number = user-chosen duration in seconds

// ADD to initial state:
timerMode: 'countdown',
customTimerSeconds: null,

// ADD to store actions:
setTimerMode: (mode: 'countdown' | 'infinity') => set({ timerMode: mode }),
setCustomTimerSeconds: (seconds: number | null) => set({ customTimerSeconds: seconds }),
```

When `timerMode === 'infinity'`, the `TimerService` (in `src/services/TimerService.ts`) must NOT start a countdown.

**Modify `src/services/TimerService.ts`:**

Read the existing `src/services/TimerService.ts`. It has a `start(durationMs: number)` method that calls `store.startTimer(durationMs)` then `this._startInterval()`.

Add an infinity guard at the top of `start()`:

```typescript
// In TimerService.start() — ADD these lines at the top, before any existing logic:
const { timerMode } = useAudioStore.getState();
if (timerMode === 'infinity') {
  // Infinity mode: do not start a countdown. Audio loops indefinitely until user stops it.
  return;
}
```

Also add the `customTimerSeconds` override: when `timerMode === 'countdown'` and `customTimerSeconds` is not null, use `customTimerSeconds * 1000` as the `durationMs` instead of the caller-provided default duration. This means the timer uses the user's custom duration rather than the standard preset (60s/120s/180s):

```typescript
// In TimerService.start() — ADD after the infinity guard, before calling store.startTimer:
let effectiveDurationMs = durationMs;
const { customTimerSeconds } = useAudioStore.getState();
if (customTimerSeconds !== null) {
  // Custom timer duration set by premium user — overrides the preset duration
  effectiveDurationMs = customTimerSeconds * 1000;
}

// Then use effectiveDurationMs instead of durationMs in the existing startTimer call:
store.startTimer(effectiveDurationMs);
// (and pass effectiveDurationMs to _startInterval if needed)
```

Full updated `start()` shape (do not change any other TimerService method):

```typescript
start(durationMs: number): void {
  this.stop(); // Clear any existing timer (existing behavior)

  const store = useAudioStore.getState();

  // AUDIO-05: Infinity mode guard — do not start countdown in infinity mode
  if (store.timerMode === 'infinity') {
    return;
  }

  // AUDIO-06: Custom timer override — premium user's chosen duration takes precedence
  const effectiveDurationMs = store.customTimerSeconds !== null
    ? store.customTimerSeconds * 1000
    : durationMs;

  store.startTimer(effectiveDurationMs);
  this._startInterval();
}
```

**Step 2 — Update app/player.tsx:**

Read the current `app/player.tsx`. It has the player UI from Phase 3: ambient video background, circular progress arc, bottom control pill with timer selection, play/stop controls. Phase 4 may have added the favorite button. Phase 5 may be unchanged in player.

Find the timer selection area (where the user picks 1, 2, or 3 min). Add two new controls alongside or below the existing timer options:

**Infinity Mode toggle:**
- A row/button that says "Infinity" with a loop/infinity icon (`Ionicons name="infinite"`)
- When `timerMode === 'infinity'`, it appears selected/active (different background or tint color)
- Tapping it:
  - If `isPremium`: toggles `timerMode` between `'infinity'` and `'countdown'`; when switching to countdown, resets to the default timer duration
  - If `!isPremium`: calls `openPaywall()` — no state change

**Custom Timer Duration input:**
- A row/button that shows "Custom" with a pencil/edit icon, OR if a custom duration is set shows the actual duration ("15 min", "45 min", etc.)
- Tapping it:
  - If `isPremium`: opens a numeric input modal or inline input where the user types a number of minutes. Accept the input and call `setCustomTimerSeconds(minutes * 60)`. Also set `timerMode` to `'countdown'` (custom timer replaces, not combines with, infinity mode). Valid range: 1–180 minutes.
  - If `!isPremium`: calls `openPaywall()` — no modal, no state change

For the numeric input, use React Native's built-in `Alert.prompt` on iOS (prompts with a text field) or an inline `TextInput` that appears in a small View. Keep it simple — no third-party picker library.

```typescript
// ADD to player.tsx imports:
import { openPaywall } from '@/src/services/PremiumPaywallService';
import { useAuthStore } from '@/src/stores/authStore';
import { Alert, TextInput } from 'react-native'; // Alert for prompt on iOS

// ADD in player component body:
const isPremium = useAuthStore((s) => s.isPremium);
const timerMode = useAudioStore((s) => s.timerMode);
const customTimerSeconds = useAudioStore((s) => s.customTimerSeconds);
const setTimerMode = useAudioStore((s) => s.setTimerMode);
const setCustomTimerSeconds = useAudioStore((s) => s.setCustomTimerSeconds);

// Infinity mode handler:
const handleInfinityPress = () => {
  if (!isPremium) {
    openPaywall();
    return;
  }
  if (timerMode === 'infinity') {
    setTimerMode('countdown'); // toggle off → back to countdown
  } else {
    setTimerMode('infinity');
    setCustomTimerSeconds(null); // clear custom duration when switching to infinity
  }
};

// Custom timer handler:
const handleCustomTimerPress = () => {
  if (!isPremium) {
    openPaywall();
    return;
  }
  // iOS: use Alert.prompt for inline text input (simplest approach, no third-party lib)
  Alert.prompt(
    'Custom Duration',
    'Enter duration in minutes (1–180)',
    (input) => {
      const minutes = parseInt(input, 10);
      if (!isNaN(minutes) && minutes >= 1 && minutes <= 180) {
        setCustomTimerSeconds(minutes * 60);
        setTimerMode('countdown'); // ensure we're in countdown mode with custom duration
      }
    },
    'plain-text',
    customTimerSeconds ? String(Math.round(customTimerSeconds / 60)) : '',
    'number-pad'
  );
  // Android fallback: since Alert.prompt is iOS-only, use a local state TextInput modal
  // Read the platform and apply the appropriate input method
};
```

For Android, `Alert.prompt` is not available. Use a local state variable `showCustomInput: boolean` to toggle an inline TextInput row. When `showCustomInput` is true, render a TextInput with `keyboardType="numeric"` and a "Set" button. On "Set", parse the input and call `setCustomTimerSeconds`. This is the simplest cross-platform approach without a third-party library.

Add the two new controls to the player UI at the appropriate position — below or alongside the existing timer buttons (1 min, 2 min, 3 min). Keep the visual style consistent with the existing timer selection buttons (dark background, white text, rounded corners, consistent padding).

Show a lock icon on Infinity and Custom controls for free users (visual cue that they are premium). The lock can be a small `Ionicons name="lock-closed"` overlaid or a subtle opacity change on the control. The full lock badge (`LockBadge`) is for the library cards — on the player controls, use a simpler inline lock cue.

The TimerService guard is described in Step 1 above — apply the changes to `src/services/TimerService.ts` as specified there. The guard goes at the top of `TimerService.start()` and reads `timerMode` directly from `useAudioStore.getState()`. The `customTimerSeconds` override goes immediately after the guard in the same method.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -30

    # Verify audioStore has timerMode and customTimerSeconds
    grep "timerMode\|customTimerSeconds" src/stores/audioStore.ts

    # Verify setTimerMode and setCustomTimerSeconds actions
    grep "setTimerMode\|setCustomTimerSeconds" src/stores/audioStore.ts

    # Verify player imports openPaywall
    grep "openPaywall" app/player.tsx

    # Verify player reads isPremium
    grep "isPremium" app/player.tsx

    # Verify Infinity mode toggle in player
    grep "infinity\|Infinity\|handleInfinityPress\|timerMode" app/player.tsx

    # Verify custom timer in player
    grep "customTimer\|Custom\|customTimerSeconds\|setCustomTimerSeconds" app/player.tsx

    # Verify paywall called for free users on both features
    grep "openPaywall" app/player.tsx
    # Expected: at least 2 occurrences (one for infinity, one for custom timer)

    # Verify infinity guard in TimerService.start()
    grep "timerMode.*infinity\|infinity.*return\|infinity.*guard" src/services/TimerService.ts
    # Expected: at least one match — the guard that returns early when timerMode === 'infinity'

    # Verify customTimerSeconds override in TimerService.start()
    grep "customTimerSeconds" src/services/TimerService.ts
    # Expected: at least one match — override logic reading customTimerSeconds from audioStore

    # Verify effectiveDurationMs (or equivalent) used instead of raw durationMs
    grep "effectiveDurationMs\|customTimerSeconds.*1000" src/services/TimerService.ts

    # Verify TimerService still has all original methods (guard must not break existing logic)
    grep "stop\|initAppStateListener\|_tick\|_onTimerExpired" src/services/TimerService.ts | head -5

    # Broader infinity guard search for defence-in-depth
    grep -rn "infinity" src/ app/ --include="*.ts" --include="*.tsx"
    # Expected: matches in audioStore.ts (timerMode field), player.tsx (UI), and TimerService.ts (guard)
    ```
    TypeScript must pass with 0 errors. All grep checks return matches. The `grep "timerMode.*infinity"` in TimerService.ts MUST return at least one match — zero matches means the guard was never applied and AUDIO-05 is broken.
  </verify>
  <done>
    - `audioStore` has `timerMode: 'countdown' | 'infinity'` (default: `'countdown'`) and `setTimerMode` action
    - `audioStore` has `customTimerSeconds: number | null` (default: `null`) and `setCustomTimerSeconds` action
    - Player screen has Infinity mode toggle: locked (callsopen paywall) for free users; toggles `timerMode` for premium users
    - Player screen has custom timer input: locked (calls openPaywall) for free users; opens numeric input for premium users; sets `customTimerSeconds`
    - Visual lock cue on Infinity and Custom controls for free users
    - `src/services/TimerService.ts` `start()` method has explicit infinity guard at the top: reads `timerMode` from `useAudioStore.getState()`; if `timerMode === 'infinity'`, returns immediately without starting any countdown
    - `src/services/TimerService.ts` `start()` method reads `customTimerSeconds` from `useAudioStore.getState()`; when not null, uses `customTimerSeconds * 1000` as `effectiveDurationMs` instead of the caller-provided preset duration
    - `customTimerSeconds` is passed to `store.startTimer(effectiveDurationMs)` — replaces the default timer selection with the user's custom duration
    - TypeScript passes with 0 errors
  </done>
</task>

</tasks>

<verification>
After completion:

```bash
cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

# Full TypeScript check
npx tsc --noEmit
# Expected: 0 errors

# audioStore: new fields present
grep "timerMode\|customTimerSeconds\|setTimerMode\|setCustomTimerSeconds" src/stores/audioStore.ts

# Player: both premium features with paywall routing
grep "openPaywall\|isPremium\|infinity\|customTimer" app/player.tsx | head -10

# Infinity mode guard in TimerService.start()
grep "timerMode.*infinity\|infinity.*return" src/services/TimerService.ts

# customTimerSeconds override in TimerService.start()
grep "customTimerSeconds" src/services/TimerService.ts

# Broader guard search
grep -rn "timerMode.*infinity\|infinity.*timerMode" src/ app/ --include="*.ts" --include="*.tsx"
```

**Manual verification** (can be done on simulator without purchase using hardcoded isPremium = true):
1. Temporarily set `isPremium: true` as default in authStore, launch app, open player — confirm Infinity mode toggle and Custom timer input are visible and functional.
2. Set `isPremium: false` (default), open player — confirm both controls show lock indicator and calling them opens the paywall.
3. Activate Infinity mode (with isPremium = true), play a sound — confirm no timer countdown starts and audio continues indefinitely.
4. Set custom timer to 15 minutes — confirm the timer runs for 15 minutes, not the default duration.
5. Revert authStore isPremium default to false before committing.
</verification>

<success_criteria>
- `audioStore.timerMode` field: `'countdown' | 'infinity'` (default: `'countdown'`)
- `audioStore.customTimerSeconds` field: `number | null` (default: `null`)
- `setTimerMode` and `setCustomTimerSeconds` actions work correctly
- Player screen Infinity mode toggle: free users see paywall; premium users toggle timerMode
- Player screen custom timer: free users see paywall; premium users enter duration in minutes; value persisted in audioStore
- `src/services/TimerService.ts` `start()` method: (1) explicit infinity guard — reads `timerMode` from `audioStore`, returns immediately if `=== 'infinity'`; (2) `customTimerSeconds` override — reads `customTimerSeconds` from `audioStore`, uses `customTimerSeconds * 1000` as `effectiveDurationMs` when non-null, overriding the caller-provided preset duration
- Timer countdown guard: when `timerMode === 'infinity'`, no countdown starts — audio loops indefinitely
- Custom timer duration used when set and `timerMode === 'countdown'`
- Both controls have a visual lock cue for free users
- `npx tsc --noEmit` exits 0 across all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/06-freemium-and-monetization/06-03-SUMMARY.md` documenting:
- audioStore: exact new fields and types added, any conflicts with Phase 2/3 timer fields (timerStartedAt, timerDurationMs)
- TimerService: where the infinity guard and customTimerSeconds override were added in `start()` — confirm both are inside the same method, before `store.startTimer()` is called
- Player screen: layout of Infinity toggle and Custom timer control relative to existing timer buttons
- Cross-platform custom timer input: Alert.prompt (iOS) vs inline TextInput (Android) — what was used
- Lock visual cue on player controls: how it was implemented (opacity, icon, etc.)
- Any deviations from the plan and why
</output>
