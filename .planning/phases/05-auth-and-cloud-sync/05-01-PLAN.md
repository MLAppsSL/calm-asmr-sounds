---
phase: 05-auth-and-cloud-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase.ts
  - src/context/AuthContext.tsx
  - src/types/index.ts
  - app/_layout.tsx
  - app/auth.tsx
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02

must_haves:
  truths:
    - "Supabase client is initialized once with session persistence via AsyncStorage — user session survives app restarts"
    - "onAuthStateChange fires on app open and restores the previous session without forcing re-login"
    - "AuthContext exposes user, isLoading, signIn, signUp, signOut — accessible from any screen via useAuth()"
    - "The root layout holds the splash screen until BOTH auth init (isLoading false) AND onboarding check complete"
    - "The auth screen presents email + password form with Sign In / Sign Up toggle as a modal sheet — reachable from Settings"
    - "Auth errors show human-readable messages (mapAuthError) — never raw Supabase error messages"
    - "All app features remain accessible without an account — no screen requires auth to render"
  artifacts:
    - path: "src/lib/supabase.ts"
      provides: "Supabase client initialized with AsyncStorage session persistence; exported as supabase"
      exports: ["supabase"]
    - path: "src/context/AuthContext.tsx"
      provides: "AuthProvider with onAuthStateChange listener; useAuth hook; signIn, signUp, signOut, user, isLoading"
      exports: ["AuthProvider", "useAuth"]
    - path: "src/types/index.ts"
      provides: "AuthUser type alias for Supabase User; FavoritesRow type for Supabase favorites table structure"
      contains: "AuthUser"
    - path: "app/_layout.tsx"
      provides: "Root layout wraps in AuthProvider; isReady gate combines !authIsLoading && hasCheckedOnboarding; auth modal screen declared"
      contains: "AuthProvider"
    - path: "app/auth.tsx"
      provides: "Modal auth screen: email + password fields, Sign In / Sign Up toggle, error display, router.back() on success"
      min_lines: 60
  key_links:
    - from: "src/lib/supabase.ts"
      to: "AsyncStorage"
      via: "AsyncStorage passed to createClient as storage option"
      pattern: "AsyncStorage"
    - from: "src/context/AuthContext.tsx"
      to: "src/lib/supabase.ts"
      via: "supabase.auth.onAuthStateChange(callback)"
      pattern: "onAuthStateChange"
    - from: "app/_layout.tsx"
      to: "src/context/AuthContext.tsx"
      via: "AuthProvider wrapping RootLayoutInner; useAuth().isLoading in isReady gate"
      pattern: "AuthProvider"
    - from: "app/auth.tsx"
      to: "src/context/AuthContext.tsx"
      via: "useAuth().signIn / signUp"
      pattern: "useAuth"
---

<objective>
Establish the Supabase Auth foundation: initialize the Supabase client with React Native session persistence, create the AuthContext provider, wire the root layout to hold the splash screen until both auth and onboarding checks complete, and build the auth modal screen.

Purpose: Every other Phase 5 plan depends on AuthContext existing and working. This plan creates the auth plumbing that FavoritesService and the migration hook build on top of.
Output: Working auth flow — sign up, sign in, sign out — with session persistence across restarts. Root layout coordinates auth init with Phase 3's onboarding check.

Note: Using Supabase Auth per locked user decision (existing Supabase usage from Phase 3). Firebase Auth and Firestore are NOT used in Phase 5.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/index.ts
@app/_layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Supabase client with AsyncStorage session persistence and add AuthUser / FavoritesRow types</name>
  <files>
    src/lib/supabase.ts
    src/types/index.ts
  </files>
  <action>
Create or update `src/lib/supabase.ts`. Per the locked user decision, Supabase Auth (email/password only) is the auth provider for Phase 5. The project already uses Supabase from Phase 3 — check if `src/lib/supabase.ts` already exists before writing it.

**Changes to src/lib/supabase.ts:**

If the file already exists (from Phase 3), read it first and extend it — do NOT overwrite the existing client or storage configuration. If it does not exist, create it from scratch.

The critical React Native requirement is to pass `AsyncStorage` as the storage adapter so the Supabase session (JWT tokens) persists across app restarts. Without this, the user is logged out every time the app closes.

```typescript
// src/lib/supabase.ts
//
// Supabase client for the app.
// CRITICAL: AsyncStorage is passed as the storage adapter so the session
// (access_token + refresh_token) survives app restarts. Without this,
// supabase-js defaults to in-memory storage and the user is logged out on close.
//
// Per locked user decision: Supabase Auth (email/password only) is the auth provider.
// Supabase is already used in Phase 3 for storage — this file may already exist.

import 'react-native-url-polyfill/auto';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false, // Required for React Native — no URL-based OAuth callbacks
  },
});
```

If `src/lib/supabase.ts` already exists from Phase 3, preserve any existing exports (e.g., storage bucket references) and only add the `auth` configuration options if they are missing. The `detectSessionInUrl: false` option is critical for React Native.

**Changes to src/types/index.ts:**

Read the current file. Add two types after the existing `Favorite` interface (from Phase 4):

```typescript
// Supabase Auth user — alias for the Supabase User type
// Used in AuthContext to type the user state without importing Supabase in every component
import type { User } from '@supabase/supabase-js';
export type AuthUser = User;

// Supabase favorites table row structure (matches the Phase 3 favorites table schema)
// Table: favorites
// Columns: id (uuid), user_id (uuid), sound_id (text), added_at (timestamptz)
export type FavoritesRow = {
  id: string;
  user_id: string;
  sound_id: string;
  added_at: string; // ISO 8601 timestamp string from Supabase
};
```

Note: `import type { User }` must be placed at the top of the types file with other imports. If there are no existing imports, add it at the top of the file.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check — must be clean
    npx tsc --noEmit 2>&1 | head -30

    # Verify supabase client is exported
    grep "export const supabase\|export { supabase" src/lib/supabase.ts

    # Verify AsyncStorage is used as storage adapter
    grep "AsyncStorage" src/lib/supabase.ts

    # Verify detectSessionInUrl: false (required for RN)
    grep "detectSessionInUrl" src/lib/supabase.ts

    # Verify new types added
    grep "AuthUser\|FavoritesRow" src/types/index.ts

    # Verify no Firebase references in new/updated files
    grep "firebase\|Firebase\|initializeAuth\|getFirestore" src/lib/supabase.ts src/types/index.ts && echo "WARNING: Firebase references found" || echo "OK: no Firebase references"
    ```
    TypeScript must pass with 0 errors. All grep checks return matches.
  </verify>
  <done>
    - `src/lib/supabase.ts` exports `supabase` client initialized with `AsyncStorage` as storage adapter
    - `detectSessionInUrl: false` is set (required for React Native)
    - `autoRefreshToken: true` and `persistSession: true` are set
    - `AuthUser` type alias (for `@supabase/supabase-js` User) exported from `src/types/index.ts`
    - `FavoritesRow` type (matching Phase 3 favorites table schema) exported from `src/types/index.ts`
    - No Firebase references in either file
    - TypeScript passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuthContext with onAuthStateChange listener and mapAuthError</name>
  <files>
    src/context/AuthContext.tsx
  </files>
  <action>
Create `src/context/AuthContext.tsx`. This is the auth state container for the entire app. Auth state lives in a React Context (not Zustand) because `onAuthStateChange` is a Supabase lifecycle subscription best managed in a Context Provider with cleanup.

Per locked user decision: Supabase Auth with email/password only. No social login. No email verification for v1.

```typescript
// src/context/AuthContext.tsx
//
// Supabase Auth state container for the app.
// Pattern: React Context (not Zustand) — Supabase auth subscriptions need cleanup on unmount.
// Using supabase.auth.onAuthStateChange() which fires:
//   1. On app open — restores persisted session or returns null
//   2. On sign in — returns SIGNED_IN event with session
//   3. On sign out — returns SIGNED_OUT event
//   4. On token refresh — returns TOKEN_REFRESHED event (handled automatically)
//
// Per locked decision: Supabase Auth (email/password only). No social login, no email verification.

import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  type PropsWithChildren,
} from 'react';
import type { User } from '@supabase/supabase-js';
import { supabase } from '@/src/lib/supabase';

interface AuthContextValue {
  user: User | null;
  isLoading: boolean; // true until first onAuthStateChange fires (after app open)
  signIn: (email: string, password: string) => Promise<{ error?: string }>;
  signUp: (email: string, password: string) => Promise<{ error?: string }>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | null>(null);

export function AuthProvider({ children }: PropsWithChildren) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true); // true until first auth state known

  useEffect(() => {
    // Get the initial session on mount (restores persisted session from AsyncStorage)
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      setIsLoading(false);
    });

    // Subscribe to auth state changes (login, logout, token refresh)
    // CRITICAL: return unsubscribe for cleanup (prevents memory leak)
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      // isLoading remains false after initial getSession resolves
    });

    return () => subscription.unsubscribe();
  }, []);

  const signIn = async (
    email: string,
    password: string
  ): Promise<{ error?: string }> => {
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) return { error: mapAuthError(error.message) };
    // onAuthStateChange fires automatically after this — sets user in state
    return {};
  };

  const signUp = async (
    email: string,
    password: string
  ): Promise<{ error?: string }> => {
    const { error } = await supabase.auth.signUp({ email, password });
    if (error) return { error: mapAuthError(error.message) };
    // Note: no email verification for v1 per locked decision.
    // Supabase auto-confirms by default unless email confirmation is enabled in the dashboard.
    return {};
  };

  const signOut = async (): Promise<void> => {
    await supabase.auth.signOut();
    // onAuthStateChange fires — sets user to null automatically
  };

  return (
    <AuthContext.Provider value={{ user, isLoading, signIn, signUp, signOut }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth(): AuthContextValue {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used inside AuthProvider');
  return ctx;
}

// Maps Supabase error messages to user-readable strings.
// Supabase returns English error messages (not error codes) — match on message substrings.
function mapAuthError(message: string): string {
  const lower = message.toLowerCase();
  if (lower.includes('invalid login credentials') || lower.includes('invalid password')) {
    return 'Incorrect email or password.';
  }
  if (lower.includes('user already registered') || lower.includes('already been registered')) {
    return 'An account with this email already exists.';
  }
  if (lower.includes('password should be at least')) {
    return 'Password must be at least 6 characters.';
  }
  if (lower.includes('unable to validate email') || lower.includes('invalid email')) {
    return 'Please enter a valid email address.';
  }
  if (lower.includes('email rate limit') || lower.includes('too many requests')) {
    return 'Too many attempts. Please try again later.';
  }
  return 'Something went wrong. Please try again.';
}
```

No additional changes needed — this file is self-contained.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -20

    # Verify AuthProvider and useAuth are exported
    grep "export function AuthProvider\|export function useAuth" src/context/AuthContext.tsx

    # Verify onAuthStateChange subscription returns cleanup function
    grep "subscription.unsubscribe\|return.*unsubscribe" src/context/AuthContext.tsx

    # Verify Supabase auth methods are used (not Firebase)
    grep "signInWithPassword\|signUp\|signOut\|onAuthStateChange" src/context/AuthContext.tsx

    # Verify isLoading starts true
    grep "useState(true)" src/context/AuthContext.tsx

    # Verify no Firebase imports
    grep "firebase\|Firebase\|initializeAuth\|onAuthStateChanged" src/context/AuthContext.tsx && echo "WARNING: Firebase found" || echo "OK: no Firebase"
    ```
    TypeScript clean. All greps return matches. No Firebase references.
  </verify>
  <done>
    - `AuthProvider` and `useAuth` exported from `src/context/AuthContext.tsx`
    - `isLoading` starts as `true`, set to `false` after initial `getSession()` resolves
    - `onAuthStateChange` subscription cleanup returned from `useEffect`
    - `signIn` uses `supabase.auth.signInWithPassword`
    - `signUp` uses `supabase.auth.signUp`
    - `signOut` uses `supabase.auth.signOut()`
    - `mapAuthError` maps Supabase error message strings to user-readable text
    - `signIn`, `signUp` return `{ error?: string }` — never throw to the caller
    - No Firebase imports or references anywhere in the file
    - TypeScript passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire root layout with combined auth + onboarding gate and add auth modal screen</name>
  <files>
    app/_layout.tsx
    app/auth.tsx
  </files>
  <action>
**Part A: Update app/_layout.tsx**

Read the current `app/_layout.tsx` (from Phase 3 plan 03-03). It currently:
- Calls `SplashScreen.preventAutoHideAsync()` at module level
- Uses a `useEffect` to check `AsyncStorage.getItem('has_seen_onboarding')` and calls `router.replace`
- Calls `SplashScreen.hideAsync()` after the check
- Returns `null` while not ready, then renders the Stack

Phase 5 must add:
1. Wrap the entire layout in `AuthProvider`
2. Coordinate auth `isLoading` with the existing onboarding readiness check
3. Add an `auth` modal screen to the Stack declaration

The approach: split into `RootLayoutInner` (uses `useAuth`) and `RootLayout` (wraps with `AuthProvider`). This avoids calling `useAuth()` outside the provider.

```typescript
import { Stack, router } from 'expo-router';
import { useEffect, useState } from 'react';
import * as SplashScreen from 'expo-splash-screen';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { AuthProvider, useAuth } from '@/src/context/AuthContext';

// MUST be at module level — called before any component renders
SplashScreen.preventAutoHideAsync();

const ONBOARDING_KEY = 'has_seen_onboarding';

function RootLayoutInner() {
  const { isLoading: authIsLoading } = useAuth();
  const [hasCheckedOnboarding, setHasCheckedOnboarding] = useState(false);

  useEffect(() => {
    async function checkOnboarding() {
      try {
        const seen = await AsyncStorage.getItem(ONBOARDING_KEY);
        if (seen) {
          router.replace('/(tabs)');
        } else {
          router.replace('/(onboarding)');
        }
      } catch {
        router.replace('/(tabs)');
      } finally {
        setHasCheckedOnboarding(true);
      }
    }
    checkOnboarding();
  }, []);

  // CRITICAL: Both auth init AND onboarding check must complete before hiding splash.
  // Auth init: getSession() + onAuthStateChange fire (typically fast from AsyncStorage).
  // Onboarding check: AsyncStorage read (fast, ~10ms).
  // Combined gate prevents: (1) flash of wrong auth state, (2) routing before onboarding known.
  const isReady = !authIsLoading && hasCheckedOnboarding;

  useEffect(() => {
    if (isReady) {
      SplashScreen.hideAsync();
    }
  }, [isReady]);

  if (!isReady) {
    return null; // Splash screen still visible
  }

  return (
    <Stack>
      <Stack.Screen name="(onboarding)" options={{ headerShown: false }} />
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      <Stack.Screen
        name="player"
        options={{
          headerShown: false,
          presentation: 'fullScreenModal',
          animation: 'fade',
        }}
      />
      {/* Auth modal — reachable from Settings, not forced on any route */}
      <Stack.Screen
        name="auth"
        options={{
          headerShown: false,
          presentation: 'modal',
        }}
      />
    </Stack>
  );
}

export default function RootLayout() {
  return (
    <AuthProvider>
      <RootLayoutInner />
    </AuthProvider>
  );
}
```

IMPORTANT: Preserve any other content in the existing `_layout.tsx` that is NOT the onboarding check or the Stack declaration. Read the file first, then merge. Do not remove imports or logic added by prior plans that is not being replaced.

**Part B: Create app/auth.tsx**

The auth screen is a modal (presented from Settings). Single form with Sign In / Sign Up toggle. Email + password only. No email verification (deferred per locked decision). No Forgot Password row (outside scope for this phase).

```typescript
// app/auth.tsx
// Modal auth screen — presented via router.push('/auth') from Settings.
// Single form with Sign In / Sign Up toggle. No forced auth anywhere in the app.
// On success: router.back() dismisses the modal; useFavoritesSync fires automatically
// via onAuthStateChange in AuthContext (implemented in Plan 02).
//
// Per locked decision: Supabase Auth, email/password only, no email verification.

import { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  SafeAreaView,
  ActivityIndicator,
} from 'react-native';
import { router } from 'expo-router';
import { useAuth } from '@/src/context/AuthContext';

type Mode = 'signin' | 'signup';

export default function AuthScreen() {
  const [mode, setMode] = useState<Mode>('signin');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { signIn, signUp } = useAuth();

  const handleSubmit = async () => {
    if (!email.trim() || !password.trim()) {
      setError('Please enter your email and password.');
      return;
    }
    setIsSubmitting(true);
    setError(null);

    const action = mode === 'signin' ? signIn : signUp;
    const result = await action(email.trim(), password);

    setIsSubmitting(false);
    if (result.error) {
      setError(result.error);
    } else {
      // Success — dismiss modal. useFavoritesSync (Plan 02) reacts to onAuthStateChange
      // and runs migration + Supabase load silently in the background.
      router.back();
    }
  };

  const toggleMode = () => {
    setMode((m) => (m === 'signin' ? 'signup' : 'signin'));
    setError(null);
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        style={styles.inner}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.title}>
            {mode === 'signin' ? 'Welcome back' : 'Create account'}
          </Text>
          <Text style={styles.subtitle}>
            {mode === 'signin'
              ? 'Sign in to sync your favorites'
              : 'Save your favorites across devices'}
          </Text>
        </View>

        {/* Form */}
        <View style={styles.form}>
          <TextInput
            style={styles.input}
            value={email}
            onChangeText={setEmail}
            placeholder="Email"
            placeholderTextColor="rgba(255,255,255,0.35)"
            autoCapitalize="none"
            keyboardType="email-address"
            autoComplete="email"
            textContentType="emailAddress"
          />
          <TextInput
            style={styles.input}
            value={password}
            onChangeText={setPassword}
            placeholder="Password"
            placeholderTextColor="rgba(255,255,255,0.35)"
            secureTextEntry
            autoComplete={mode === 'signup' ? 'new-password' : 'current-password'}
            textContentType={mode === 'signup' ? 'newPassword' : 'password'}
          />

          {error && <Text style={styles.errorText}>{error}</Text>}

          <Pressable
            style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
            onPress={handleSubmit}
            disabled={isSubmitting}
          >
            {isSubmitting ? (
              <ActivityIndicator color="#ffffff" />
            ) : (
              <Text style={styles.submitText}>
                {mode === 'signin' ? 'Sign In' : 'Create Account'}
              </Text>
            )}
          </Pressable>
        </View>

        {/* Toggle mode */}
        <Pressable onPress={toggleMode} style={styles.toggleRow}>
          <Text style={styles.toggleText}>
            {mode === 'signin'
              ? "Don't have an account? "
              : 'Already have an account? '}
            <Text style={styles.toggleLink}>
              {mode === 'signin' ? 'Sign up' : 'Sign in'}
            </Text>
          </Text>
        </Pressable>

        {/* Dismiss without auth */}
        <Pressable onPress={() => router.back()} style={styles.skipRow}>
          <Text style={styles.skipText}>Continue without account</Text>
        </Pressable>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0f1115',
  },
  inner: {
    flex: 1,
    paddingHorizontal: 24,
    paddingTop: 40,
    justifyContent: 'center',
  },
  header: {
    marginBottom: 40,
    alignItems: 'center',
  },
  title: {
    color: '#ffffff',
    fontSize: 28,
    fontWeight: '600',
    marginBottom: 8,
  },
  subtitle: {
    color: 'rgba(255,255,255,0.5)',
    fontSize: 15,
    textAlign: 'center',
  },
  form: {
    gap: 12,
    marginBottom: 24,
  },
  input: {
    backgroundColor: 'rgba(255,255,255,0.08)',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.12)',
    paddingHorizontal: 16,
    paddingVertical: 14,
    color: '#ffffff',
    fontSize: 16,
  },
  errorText: {
    color: '#ef4444',
    fontSize: 14,
    textAlign: 'center',
  },
  submitButton: {
    backgroundColor: '#8b5cf6',
    borderRadius: 14,
    height: 52,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 4,
  },
  submitButtonDisabled: {
    opacity: 0.6,
  },
  submitText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  toggleRow: {
    alignItems: 'center',
    marginBottom: 16,
  },
  toggleText: {
    color: 'rgba(255,255,255,0.5)',
    fontSize: 14,
  },
  toggleLink: {
    color: '#8b5cf6',
    fontWeight: '600',
  },
  skipRow: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  skipText: {
    color: 'rgba(255,255,255,0.3)',
    fontSize: 13,
  },
});
```
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -20

    # Verify AuthProvider wraps layout
    grep "AuthProvider" app/_layout.tsx

    # Verify combined isReady gate
    grep "authIsLoading\|hasCheckedOnboarding" app/_layout.tsx

    # Verify auth modal screen declared in Stack
    grep "auth" app/_layout.tsx | grep "Stack.Screen"

    # Verify auth.tsx exists with correct exports
    grep "export default function AuthScreen" app/auth.tsx

    # Verify auth screen calls router.back() on success
    grep "router.back" app/auth.tsx

    # Verify no Firebase references in layout or auth screen
    grep "firebase\|Firebase\|initializeAuth\|firestore" app/_layout.tsx app/auth.tsx && echo "WARNING: Firebase found" || echo "OK: no Firebase"

    # Verify no forced auth redirects exist anywhere (auth is optional)
    grep -rn "Stack.Protected\|redirect.*auth\|requiresAuth" app/ src/ --include="*.tsx" --include="*.ts" 2>/dev/null && echo "WARNING: forced auth found" || echo "OK: auth is optional"
    ```
    TypeScript clean. All greps return matches. No Firebase references. No forced auth patterns found.
  </verify>
  <done>
    - `app/_layout.tsx` wraps in `AuthProvider`; `RootLayoutInner` uses `useAuth().isLoading` in combined isReady gate
    - Splash screen hidden only when both `!authIsLoading` AND `hasCheckedOnboarding` are true
    - Stack declares `auth` screen with `presentation: 'modal'`
    - `app/auth.tsx` renders email/password form with Sign In / Sign Up toggle
    - `app/auth.tsx` calls `router.back()` on successful auth
    - `app/auth.tsx` shows human-readable error messages (from `mapAuthError` via `useAuth`)
    - No Firebase references in any file
    - No route forces authentication — all screens accessible without account
    - TypeScript passes with no errors
  </done>
</task>

</tasks>

<verification>
After all three tasks complete:

```bash
cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

# Full TypeScript check — must be clean
npx tsc --noEmit

# Supabase client initialization
grep "createClient\|AsyncStorage\|detectSessionInUrl" src/lib/supabase.ts

# Supabase export present
grep "export const supabase" src/lib/supabase.ts

# AuthProvider is the outermost wrapper in layout
grep -A5 "export default function RootLayout" app/_layout.tsx

# Combined isReady gate
grep "isReady\|authIsLoading\|hasCheckedOnboarding" app/_layout.tsx | head -10

# Auth modal screen in Stack
grep -A3 "name=\"auth\"" app/_layout.tsx

# Auth screen form elements
grep "TextInput\|signIn\|signUp\|router.back" app/auth.tsx | head -10

# Confirm no Firebase references in Phase 5 files
grep -rn "firebase\|Firebase\|initializeAuth\|getFirestore\|firestore.rules" \
  src/lib/supabase.ts src/context/AuthContext.tsx app/_layout.tsx app/auth.tsx 2>/dev/null \
  && echo "WARNING: Firebase references found" || echo "OK: Supabase only"
```
</verification>

<success_criteria>
- `src/lib/supabase.ts` exports `supabase` client with `AsyncStorage` as storage adapter and `detectSessionInUrl: false`
- `src/context/AuthContext.tsx` exports `AuthProvider` and `useAuth` using `supabase.auth` API (not Firebase)
- `app/_layout.tsx` wraps in `AuthProvider`; splash held until both auth init AND onboarding check complete
- `app/auth.tsx` is a modal screen with email/password Sign In / Sign Up form; dismisses on success
- No Firestore security rules file (Supabase RLS is configured in the Supabase dashboard, not a local file)
- No Firebase imports in any Phase 5 file
- `npx tsc --noEmit` exits 0 across all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/05-auth-and-cloud-sync/05-01-SUMMARY.md` documenting:
- supabase.ts: what was changed/created — AsyncStorage storage adapter setup, detectSessionInUrl rationale
- AuthContext: shape of AuthContextValue, getSession() + onAuthStateChange() combination pattern
- mapAuthError: how Supabase error message strings are mapped (substring matching vs Firebase error codes)
- Root layout gate: how isReady combines auth + onboarding (especially if Phase 3 implementation differed from plan)
- auth.tsx: any UX deviations from the plan
- Note: Supabase RLS policies must be set in the Supabase dashboard for the favorites table (handled in Plan 02 context note)
- Any TypeScript issues encountered and how resolved
</output>
