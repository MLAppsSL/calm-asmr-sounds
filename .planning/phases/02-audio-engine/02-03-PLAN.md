---
phase: 02-audio-engine
plan: "03"
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/services/TimerService.ts
  - src/stores/audioStore.ts
  - app/_layout.tsx
autonomous: false

requirements: [AUDIO-03, AUDIO-04]

must_haves:
  truths:
    - "The timer counts down correctly after the app is backgrounded and resumed — no drift from setInterval alone"
    - "When the timer reaches zero, audio fades out gently then stops — not a hard cut"
    - "Switching sounds resets the timer to its original selected duration (does not continue counting)"
    - "User can change timer duration mid-session — the new duration takes effect from that moment"
    - "Loop mode is always active — no manual toggle needed — sounds repeat seamlessly until stopped"
    - "AudioService.initialize() is called exactly once at app startup"
    - "On real iOS device: audio plays through a screen lock with the silent switch ON"
    - "On real Android device: audio plays after switching to another app"
  artifacts:
    - path: "src/services/TimerService.ts"
      provides: "AppState-aware countdown that calls AudioService.fadeOut then stop at zero"
      exports: ["TimerService"]
      min_lines: 80
    - path: "src/stores/audioStore.ts"
      provides: "Augmented Zustand store with timerStartedAt, timerDurationMs, and timer control actions"
      exports: ["useAudioStore"]
    - path: "app/_layout.tsx"
      provides: "Root layout that calls AudioService.initialize() and mounts TimerService AppState listener on startup"
  key_links:
    - from: "src/services/TimerService.ts"
      to: "src/services/AudioService.ts"
      via: "AudioService.fadeOut(durationMs) then AudioService.stop()"
      pattern: "AudioService\\.fadeOut"
    - from: "src/services/TimerService.ts"
      to: "AppState (react-native)"
      via: "AppState.addEventListener('change', ...) to recalculate elapsed on foreground"
      pattern: "AppState\\.addEventListener"
    - from: "src/stores/audioStore.ts"
      to: "src/services/TimerService.ts"
      via: "TimerService reads timerStartedAt + timerDurationMs from store"
      pattern: "timerStartedAt"
    - from: "app/_layout.tsx"
      to: "src/services/AudioService.ts"
      via: "AudioService.initialize() called in useEffect on mount"
      pattern: "AudioService\\.initialize"
---

<objective>
Wire the audio engine together: TimerService (AppState-aware countdown with fade-and-stop), an augmented audioStore (timer timestamp fields), and app/_layout.tsx initialization (AudioService.initialize + TimerService AppState listener). Ends with a human verification checkpoint confirming background audio works on real devices.

Purpose: Without AppState-aware timer correction, the countdown drifts when the app is backgrounded on iOS (JS timers pause). Without AudioService.initialize() called at startup, audio never plays in silent mode. This plan makes the engine production-ready.

Output: `src/services/TimerService.ts`, augmented `src/stores/audioStore.ts`, updated `app/_layout.tsx`, verified on real devices.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-engine/02-RESEARCH.md
@.planning/phases/02-audio-engine/02-CONTEXT.md
@.planning/phases/02-audio-engine/02-01-SUMMARY.md
@.planning/phases/02-audio-engine/02-02-SUMMARY.md
@src/stores/audioStore.ts
@src/types/index.ts
@src/services/AudioService.ts
@app/_layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Augment audioStore with timer timestamp fields</name>
  <files>
    src/stores/audioStore.ts
  </files>
  <action>
Augment the existing `src/stores/audioStore.ts` (created in Phase 01-03) by adding timer timestamp fields and control actions. Do NOT rewrite the store — add to it.

**Why timestamp math instead of interval counting:**
`setInterval` pauses on iOS when the app is backgrounded. To avoid drift, the timer stores `timerStartedAt: number` (epoch ms from `Date.now()`) and `timerDurationMs: number`. On each tick AND on AppState `change → active`, TimerService recomputes remaining time as `timerDurationMs - (Date.now() - timerStartedAt)`. This pattern is correct; interval counting is not.

**Fields to add to `AudioState` interface:**
```typescript
timerStartedAt: number | null;    // Date.now() when timer started; null = timer not running
timerDurationMs: number;          // Current timer duration in milliseconds
```

**Actions to add:**
```typescript
startTimer: (durationMs: number) => void;
// Sets timerStartedAt = Date.now(), timerDurationMs = durationMs

resetTimer: () => void;
// Sets timerStartedAt to Date.now() (resets to full duration), keeps timerDurationMs unchanged
// Used when switching sounds: reset to original duration

stopTimer: () => void;
// Sets timerStartedAt = null (timer not running)

setTimerDuration: (durationMs: number) => void;
// Updates timerDurationMs; if timer is running, also resets timerStartedAt to now
// Implements LOCKED decision: mid-session timer change allowed — new duration takes effect immediately
```

**Default values:**
- `timerStartedAt: null` (not running initially)
- `timerDurationMs: 60_000` (1 minute default, matching existing `timerSeconds: 60`)

**Keep all existing fields** (`currentSoundId`, `isPlaying`, `isLooping`, `timerSeconds`, `volume`, and all existing setters + `reset`). Add the new timer timestamp fields alongside them.

**Update the `reset` action** to also clear `timerStartedAt: null` and restore `timerDurationMs: 60_000`.

Preserve the Zustand v5 `create<T>()()` double-parens pattern from Phase 01-03.
  </action>
  <verify>
```bash
# TypeScript check
npx tsc --noEmit

# Verify new fields exist
grep "timerStartedAt" src/stores/audioStore.ts
grep "timerDurationMs" src/stores/audioStore.ts

# Verify new actions exist
grep "startTimer" src/stores/audioStore.ts
grep "resetTimer" src/stores/audioStore.ts
grep "stopTimer" src/stores/audioStore.ts
grep "setTimerDuration" src/stores/audioStore.ts

# Verify existing fields preserved
grep "currentSoundId" src/stores/audioStore.ts
grep "isPlaying" src/stores/audioStore.ts
grep "useAudioStore" src/stores/audioStore.ts
```
  </verify>
  <done>
- `src/stores/audioStore.ts` has `timerStartedAt: number | null` and `timerDurationMs: number` fields
- `startTimer`, `resetTimer`, `stopTimer`, `setTimerDuration` actions are present and correct
- All existing fields from Phase 01-03 (currentSoundId, isPlaying, isLooping, timerSeconds, volume, setters, reset) are preserved
- `npx tsc --noEmit` passes with 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 2: TimerService and app startup wiring</name>
  <files>
    src/services/TimerService.ts
    app/_layout.tsx
  </files>
  <action>
Create `src/services/TimerService.ts` and update `app/_layout.tsx` to initialize both AudioService and TimerService at startup.

---

**src/services/TimerService.ts:**

The timer service runs a 1-second interval to tick down remaining time, but always computes remaining time from `Date.now() - timerStartedAt` (not from counting intervals). When AppState transitions back to `active`, it immediately recalculates without waiting for the next tick.

LOCKED decisions implemented here:
- Timer reaching zero: audio fades out gently (AudioService.fadeOut), then hard stop
- Timer fade duration on zero: use 1500ms (Claude's Discretion — soft but quick)
- Mid-session timer change: handled in audioStore.setTimerDuration — TimerService just reads from store
- Switching sounds resets timer: caller (in Phase 3 UI) calls `audioStore.resetTimer()` — TimerService sees new timerStartedAt and keeps going

```typescript
// src/services/TimerService.ts
//
// AppState-aware timer service. Uses timestamp math (not interval counting) to prevent
// drift when the app is backgrounded on iOS (JS timers pause in background).
//
// Start a timer: call start(). Stop prematurely: call stop().
// TimerService reads/writes audioStore directly for timer state.

import { AppState, AppStateStatus } from 'react-native';
import { AudioService } from './AudioService';
import { useAudioStore } from '../stores/audioStore';

// Duration of the fade-out when timer reaches zero (Claude's Discretion)
const TIMER_FADE_MS = 1500;

class TimerServiceClass {
  private intervalId: ReturnType<typeof setInterval> | null = null;
  private appStateSubscription: ReturnType<typeof AppState.addEventListener> | null = null;
  private isFadingOut = false;

  /**
   * Start the countdown. Stores timerStartedAt in audioStore so timestamp math works
   * even if the service is recreated.
   *
   * Call this when the user selects a timer duration and taps a sound.
   */
  start(durationMs: number): void {
    this.stop(); // Clear any existing timer

    const store = useAudioStore.getState();
    store.startTimer(durationMs);

    this._startInterval();
  }

  /**
   * Stop the timer immediately (no fade). Called on manual sound toggle-off.
   */
  stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.isFadingOut = false;
    useAudioStore.getState().stopTimer();
  }

  /**
   * Initialize the AppState listener. Call once at app startup.
   * On 'active', immediately recalculates remaining time without waiting for next interval tick.
   */
  initAppStateListener(): void {
    if (this.appStateSubscription) return; // Already initialized

    this.appStateSubscription = AppState.addEventListener(
      'change',
      (nextState: AppStateStatus) => {
        if (nextState === 'active') {
          this._tick();
        }
      }
    );
  }

  /**
   * Remove AppState listener. Call on app teardown (rarely needed in Expo).
   */
  removeAppStateListener(): void {
    if (this.appStateSubscription) {
      this.appStateSubscription.remove();
      this.appStateSubscription = null;
    }
  }

  // ─── Private ──────────────────────────────────────────────────────────────

  private _startInterval(): void {
    this.intervalId = setInterval(() => {
      this._tick();
    }, 1000);
  }

  private _tick(): void {
    if (this.isFadingOut) return;

    const { timerStartedAt, timerDurationMs } = useAudioStore.getState();
    if (timerStartedAt === null) return; // Timer not running

    const elapsed = Date.now() - timerStartedAt;
    const remaining = timerDurationMs - elapsed;

    if (remaining <= 0) {
      this._onTimerExpired();
    }
    // Note: remaining time display is computed by components from timerStartedAt + timerDurationMs
    // directly — no separate "remainingMs" field needed in the store.
  }

  private async _onTimerExpired(): Promise<void> {
    if (this.isFadingOut) return;
    this.isFadingOut = true;

    // Stop the interval before the async fade to prevent re-entry
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }

    // LOCKED: timer reaching zero → audio fades out gently, then stops
    await AudioService.fadeOut(TIMER_FADE_MS);
    AudioService.stop();

    // Clear timer state in store
    useAudioStore.getState().stopTimer();
    useAudioStore.getState().setIsPlaying(false);

    this.isFadingOut = false;
  }
}

export const TimerService = new TimerServiceClass();
```

---

**app/_layout.tsx — Add AudioService.initialize() and TimerService.initAppStateListener():**

Update the existing root layout to call both services on mount. Keep all existing route structure intact — only add the initialization useEffect.

```typescript
// Add to existing app/_layout.tsx:
// 1. Import AudioService and TimerService
// 2. Add useEffect that calls both on mount

import { useEffect } from 'react';
import { Stack } from 'expo-router';
import { AudioService } from '../src/services/AudioService';
import { TimerService } from '../src/services/TimerService';

export default function RootLayout() {
  useEffect(() => {
    // Initialize audio session once at app startup.
    // This configures: playsInSilentModeIOS, staysActiveInBackground, interruptionMode.
    // Must be called before any audio playback attempt.
    AudioService.initialize().catch((err) =>
      console.error('[RootLayout] AudioService.initialize failed:', err)
    );

    // Register AppState listener for timer drift correction.
    // When app returns to foreground, timer recalculates elapsed time from stored timestamp.
    TimerService.initAppStateListener();

    return () => {
      TimerService.removeAppStateListener();
    };
  }, []);

  return (
    <Stack>
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      <Stack.Screen name="(onboarding)" options={{ headerShown: false }} />
      <Stack.Screen name="(auth)" options={{ headerShown: false }} />
      <Stack.Screen
        name="player"
        options={{
          presentation: 'modal',
          headerShown: false,
        }}
      />
    </Stack>
  );
}
```

Note: Preserve the exact existing Stack.Screen configuration from Phase 01-03. Only add the import statements and the useEffect block.
  </action>
  <verify>
```bash
# TypeScript check — full project
npx tsc --noEmit

# Verify TimerService uses timestamp math (not interval counting)
grep "Date.now()" src/services/TimerService.ts
grep "timerStartedAt" src/services/TimerService.ts

# Verify AppState listener exists
grep "AppState.addEventListener" src/services/TimerService.ts

# Verify fade on timer expiry (LOCKED behavior)
grep "AudioService.fadeOut" src/services/TimerService.ts
grep "AudioService.stop" src/services/TimerService.ts

# Verify TimerService is a module-level singleton
grep "export const TimerService = new TimerServiceClass" src/services/TimerService.ts

# Verify AudioService.initialize() called in _layout.tsx
grep "AudioService.initialize" app/_layout.tsx

# Verify TimerService.initAppStateListener() called in _layout.tsx
grep "TimerService.initAppStateListener" app/_layout.tsx

# Verify Stack.Screen for player still has presentation modal (not broken)
grep "presentation.*modal" app/_layout.tsx
```
  </verify>
  <done>
- `src/services/TimerService.ts` exports `TimerService` singleton
- Timer uses timestamp math: `timerDurationMs - (Date.now() - timerStartedAt)`
- AppState `active` event immediately re-ticks without waiting for interval
- Timer expiry: `AudioService.fadeOut(1500)` then `AudioService.stop()`
- `app/_layout.tsx` calls `AudioService.initialize()` and `TimerService.initAppStateListener()` in a useEffect on mount
- All existing Stack.Screen configuration from Phase 01-03 is preserved
- `npx tsc --noEmit` passes with 0 errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify audio engine on real devices (background audio, loop, timer)</name>
  <files></files>
  <action>
First, add a temporary test harness to app/(tabs)/index.tsx to enable on-device testing. Add a TouchableOpacity that calls `SoundCacheService.getLocalUri(SOUNDS[0])` then `AudioService.play(SOUNDS[0].id, uri)` on press. Import SOUNDS from config/sounds.ts. This is a test scaffold — Phase 3 will replace it with the real UI.

Then trigger EAS Development Builds and install on real devices:

```bash
# Build for both platforms
eas build --platform all --profile development --non-interactive
```

Install on real iOS and Android devices (not simulators — background audio requires real hardware).
  </action>
  <verify>
**Step 1 — Auto-play (AUDIO-01):**
1. Open app on device, tap the test button
2. Expected: Audio starts within 1-2 seconds (download on first play, instant on repeat)
3. Tap same sound again: Expected: Audio stops immediately (toggle-off, no fade)
4. Tap a different sound while one is playing: Expected: Smooth crossfade over ~0.7 seconds

**Step 2 — Background audio on iOS (AUDIO-02):**
1. Start playing a sound
2. Press Home button, then lock screen (silent switch ON)
3. Wait 10 seconds
4. Expected: Audio continues playing through the lock screen

**Step 3 — Background audio on Android (AUDIO-02):**
1. Start playing a sound
2. Switch to another app (e.g., Chrome)
3. Wait 10 seconds
4. Expected: Audio continues in background

**Step 4 — Loop (AUDIO-03):**
Play sound past its ~30s clip end.
Expected: Loops seamlessly. Note any audible gap — if gap exists on iOS, CAF format conversion is needed.

**Step 5 — Timer (AUDIO-04):**
1. Temporarily set default timerDurationMs to 10_000 (10 seconds) in audioStore
2. Start playing — wait 10 seconds
3. Expected: Audio fades out gently (~1.5s) then stops
4. Repeat with app backgrounded: background immediately after starting, return after 10 seconds
5. Expected: Audio stopped (timer fired correctly during background — AppState correction working)

**Step 6 — Document findings:**
- iOS gapless loop: gap or no gap?
- Firebase Storage download: succeeds without auth or 403?
- setAudioModeAsync mid-crossfade: any audio interruption?
  </verify>
  <done>
- Auto-play starts audio in under 2 seconds on both platforms
- Audio plays through screen lock on iOS (silent switch ON)
- Audio plays after app switch on Android
- Sound loops continuously past clip boundary
- Timer stops audio after countdown with gentle fade
- Timer fires correctly after backgrounding (no drift from AppState correction)
  </done>
</task>

</tasks>

<verification>
After automated tasks complete (before checkpoint):

```bash
# Full project TypeScript
npx tsc --noEmit
# Expected: 0 errors

# Timer uses timestamp math
grep "Date.now()" src/services/TimerService.ts

# AppState listener registered
grep "AppState.addEventListener" src/services/TimerService.ts

# AudioService fade-then-stop on timer expiry
grep "AudioService.fadeOut" src/services/TimerService.ts

# audioStore has all new fields
grep "timerStartedAt" src/stores/audioStore.ts
grep "timerDurationMs" src/stores/audioStore.ts
grep "startTimer\|resetTimer\|stopTimer\|setTimerDuration" src/stores/audioStore.ts | wc -l
# Expected: 4

# app/_layout.tsx has both initializations
grep "AudioService.initialize\|TimerService.initAppStateListener" app/_layout.tsx | wc -l
# Expected: 2

# Lint passes
npx eslint . --ext .ts,.tsx --max-warnings=0
```
</verification>

<success_criteria>
- `src/services/TimerService.ts` uses timestamp math (`Date.now() - timerStartedAt`) for drift-free countdown
- AppState `active` event triggers an immediate tick (no wait for next interval)
- Timer expiry: `AudioService.fadeOut(1500)` followed by `AudioService.stop()`
- `src/stores/audioStore.ts` has `timerStartedAt`, `timerDurationMs`, `startTimer`, `resetTimer`, `stopTimer`, `setTimerDuration` — all existing fields preserved
- `app/_layout.tsx` calls `AudioService.initialize()` and `TimerService.initAppStateListener()` on mount
- Human checkpoint verified: auto-play works, background audio works on iOS and Android, loop plays continuously, timer stops audio after countdown
- `npx tsc --noEmit` and `npx eslint . --ext .ts,.tsx --max-warnings=0` pass
</success_criteria>

<output>
After checkpoint approval, create `.planning/phases/02-audio-engine/02-03-SUMMARY.md` following the summary template.
</output>
