---
phase: 05-auth-and-cloud-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/firebase.ts
  - src/context/AuthContext.tsx
  - src/types/index.ts
  - app/_layout.tsx
  - app/auth.tsx
  - firestore.rules
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02

must_haves:
  truths:
    - "Firebase Auth is initialized with initializeAuth + getReactNativePersistence(AsyncStorage) — user session survives app restarts"
    - "onAuthStateChanged fires on app open and restores the previous session without forcing re-login"
    - "AuthContext exposes user, isLoading, signIn, signUp, signOut — accessible from any screen via useAuth()"
    - "The root layout holds the splash screen until BOTH auth init (isLoading false) AND onboarding check complete"
    - "The auth screen presents email + password form with Sign In / Sign Up toggle as a modal sheet — reachable from Settings"
    - "Auth errors show human-readable messages (mapAuthError) — never raw Firebase error codes"
    - "All app features remain accessible without an account — no screen requires auth to render"
    - "Firestore security rules deny reads/writes to any user's favorites document unless auth.uid matches the document uid"
  artifacts:
    - path: "src/lib/firebase.ts"
      provides: "initializeAuth with getReactNativePersistence(AsyncStorage) guard against re-init; db = getFirestore(app)"
      exports: ["auth", "db"]
    - path: "src/context/AuthContext.tsx"
      provides: "AuthProvider with onAuthStateChanged listener; useAuth hook; signIn, signUp, signOut, user, isLoading"
      exports: ["AuthProvider", "useAuth"]
    - path: "src/types/index.ts"
      provides: "AuthUser type alias for Firebase User; FavoritesMap type for Firestore structure"
      contains: "AuthUser"
    - path: "app/_layout.tsx"
      provides: "Root layout wraps in AuthProvider; isReady gate combines !authIsLoading && hasCheckedOnboarding; auth modal screen declared"
      contains: "AuthProvider"
    - path: "app/auth.tsx"
      provides: "Modal auth screen: email + password fields, Sign In / Sign Up toggle, error display, router.back() on success"
      min_lines: 60
    - path: "firestore.rules"
      provides: "rules_version 2; allow read, write on users/{uid} only if request.auth.uid == uid"
      contains: "request.auth.uid == uid"
  key_links:
    - from: "src/lib/firebase.ts"
      to: "getReactNativePersistence(AsyncStorage)"
      via: "initializeAuth persistence option"
      pattern: "getReactNativePersistence"
    - from: "src/context/AuthContext.tsx"
      to: "src/lib/firebase.ts"
      via: "onAuthStateChanged(auth, ...)"
      pattern: "onAuthStateChanged"
    - from: "app/_layout.tsx"
      to: "src/context/AuthContext.tsx"
      via: "AuthProvider wrapping RootLayoutInner; useAuth().isLoading in isReady gate"
      pattern: "AuthProvider"
    - from: "app/auth.tsx"
      to: "src/context/AuthContext.tsx"
      via: "useAuth().signIn / signUp"
      pattern: "useAuth"
---

<objective>
Establish the Firebase Auth foundation: initialize auth with React Native session persistence, create the AuthContext provider, wire the root layout to hold the splash screen until both auth and onboarding checks complete, build the auth modal screen, and deploy Firestore security rules for user data isolation.

Purpose: Every other Phase 5 plan depends on AuthContext existing and working. This plan creates the auth plumbing that FavoritesService and the migration hook build on top of.
Output: Working auth flow — sign up, sign in, sign out — with session persistence across restarts. Root layout coordinates auth init with Phase 3's onboarding check. Firestore rules deployed and blocking cross-user data access.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-auth-and-cloud-sync/05-RESEARCH.md
@src/lib/firebase.ts
@src/types/index.ts
@app/_layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade firebase.ts to use initializeAuth with React Native persistence and add AuthUser / FavoritesMap types</name>
  <files>
    src/lib/firebase.ts
    src/types/index.ts
  </files>
  <action>
Read `src/lib/firebase.ts` first. The Phase 1 scaffold initialized Firebase with `initializeApp` and likely used `getAuth(app)` for auth. Phase 5 must switch to `initializeAuth` with `getReactNativePersistence(AsyncStorage)` — this is the critical change that makes the user's session survive app restarts.

**Changes to src/lib/firebase.ts:**

1. Add imports:
   ```typescript
   import { initializeAuth, getReactNativePersistence } from 'firebase/auth';
   import AsyncStorage from '@react-native-async-storage/async-storage';
   import { getFirestore } from 'firebase/firestore';
   ```

2. Change the auth initialization. Replace any existing `getAuth(app)` call with:
   ```typescript
   // Guard against re-initialization on Expo hot reload
   const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];

   // CRITICAL: initializeAuth (not getAuth) — required for session persistence in React Native.
   // Without getReactNativePersistence, Firebase falls back to in-memory persistence and the
   // user is logged out every time the app closes. This is the standard React Native pattern.
   // @ts-ignore — getReactNativePersistence has a TypeScript definition gap in some SDK versions
   //              (firebase-js-sdk issues #9316, #7584); the function exists and works at runtime.
   export const auth = initializeAuth(app, {
     persistence: getReactNativePersistence(AsyncStorage),
   });

   export const db = getFirestore(app);
   ```

   If `initializeAuth` is called again on hot reload it throws "auth/already-initialized". Guard it:
   ```typescript
   import { initializeAuth, getAuth, getReactNativePersistence } from 'firebase/auth';
   // ...
   let auth;
   try {
     // @ts-ignore — TypeScript definition gap for getReactNativePersistence
     auth = initializeAuth(app, {
       persistence: getReactNativePersistence(AsyncStorage),
     });
   } catch (e: any) {
     // Already initialized (hot reload) — get the existing instance
     auth = getAuth(app);
   }
   export { auth };
   ```

   Use whichever approach the existing firebase.ts favors for re-init guarding. The `getApps()` guard on `initializeApp` prevents the app-level re-init; the try/catch prevents the auth-level re-init.

3. Ensure `export const db = getFirestore(app);` is present (needed by FavoritesService in Plan 02).

**Changes to src/types/index.ts:**

Read the current file. Add two types after the existing `Favorite` interface (from Phase 4):

```typescript
// Firebase Auth user — alias for the Firebase User type
// Used in AuthContext to type the user state without importing Firebase in every component
import type { User } from 'firebase/auth';
export type AuthUser = User;

// Firestore favorites document structure at users/{uid}
// Map keyed by sound ID — naturally deduplicates (unlike arrays with arrayUnion).
// Research finding: arrayUnion cannot deduplicate objects by partial field equality.
export type FavoritesMap = Record<string, { addedAt: number }>;
```

Note: The `import type { User }` must be placed at the top of the types file with other imports, not inline in the type definition. If there are no existing imports (types are only interface definitions), use `import type` at the top of the file.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check — must be clean
    npx tsc --noEmit 2>&1 | head -30

    # Verify initializeAuth with RN persistence is in firebase.ts
    grep "getReactNativePersistence\|initializeAuth" src/lib/firebase.ts

    # Verify db export exists
    grep "export.*db\|getFirestore" src/lib/firebase.ts

    # Verify getApps() guard exists (prevents re-init on hot reload)
    grep "getApps" src/lib/firebase.ts

    # Verify new types added
    grep "AuthUser\|FavoritesMap" src/types/index.ts

    # Verify auth is NOT using the old getAuth pattern (without persistence)
    grep "^export const auth = getAuth" src/lib/firebase.ts && echo "WARNING: using getAuth without persistence" || echo "OK: using initializeAuth"
    ```
    TypeScript must pass with 0 errors. All grep checks return matches.
  </verify>
  <done>
    - `src/lib/firebase.ts` uses `initializeAuth` with `getReactNativePersistence(AsyncStorage)` — not bare `getAuth`
    - `auth` and `db` are both exported from `src/lib/firebase.ts`
    - `getApps()` or try/catch guard prevents re-initialization errors on hot reload
    - `AuthUser` type alias (for `firebase/auth` User) exported from `src/types/index.ts`
    - `FavoritesMap` type (`Record<string, { addedAt: number }>`) exported from `src/types/index.ts`
    - TypeScript passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuthContext with onAuthStateChanged listener and mapAuthError</name>
  <files>
    src/context/AuthContext.tsx
  </files>
  <action>
Create `src/context/AuthContext.tsx`. This is the auth state container for the entire app. Per Expo Router's official pattern and the research recommendation, auth state lives in a React Context (not Zustand) because `onAuthStateChanged` is a Firebase lifecycle hook best managed in a Context Provider.

```typescript
// src/context/AuthContext.tsx
//
// Firebase Auth state container for the app.
// Pattern: React Context (not Zustand) — recommended by Expo Router docs for auth state.
// Reason: onAuthStateChanged is a Firebase lifecycle hook; React Context is the idiomatic
//         way to manage subscriptions that need cleanup. Zustand lacks native lifecycle hooks.
//
// Source: https://docs.expo.dev/router/advanced/authentication/ (adapted for Firebase)
// Source: https://firebase.google.com/docs/auth/web/password-auth

import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  type PropsWithChildren,
} from 'react';
import {
  onAuthStateChanged,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut as firebaseSignOut,
  type User,
} from 'firebase/auth';
import { auth } from '@/src/lib/firebase';

interface AuthContextValue {
  user: User | null;
  isLoading: boolean; // true until first onAuthStateChanged fires (after app open)
  signIn: (email: string, password: string) => Promise<{ error?: string }>;
  signUp: (email: string, password: string) => Promise<{ error?: string }>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | null>(null);

export function AuthProvider({ children }: PropsWithChildren) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true); // true until first auth state known

  useEffect(() => {
    // onAuthStateChanged fires:
    // 1. On app open — restores persisted session or returns null
    // 2. On sign in — returns the logged-in User
    // 3. On sign out — returns null
    // CRITICAL: return unsubscribe for cleanup (prevents memory leak / test warnings)
    const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {
      setUser(firebaseUser);
      setIsLoading(false);
    });
    return unsubscribe;
  }, []);

  const signIn = async (
    email: string,
    password: string
  ): Promise<{ error?: string }> => {
    try {
      await signInWithEmailAndPassword(auth, email, password);
      // onAuthStateChanged fires automatically after this — sets user in state
      return {};
    } catch (e: any) {
      return { error: mapAuthError(e.code) };
    }
  };

  const signUp = async (
    email: string,
    password: string
  ): Promise<{ error?: string }> => {
    try {
      await createUserWithEmailAndPassword(auth, email, password);
      return {};
    } catch (e: any) {
      return { error: mapAuthError(e.code) };
    }
  };

  const signOut = async (): Promise<void> => {
    await firebaseSignOut(auth);
    // onAuthStateChanged fires — sets user to null automatically
  };

  return (
    <AuthContext.Provider value={{ user, isLoading, signIn, signUp, signOut }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth(): AuthContextValue {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used inside AuthProvider');
  return ctx;
}

// Maps Firebase error codes to user-readable strings.
// Handles both legacy (auth/wrong-password) and modern (auth/invalid-credential) codes
// — Firebase JS SDK v10+ changed the error code for wrong password as a security improvement
// to prevent email enumeration. Both codes must be handled.
// Source: https://firebase.google.com/docs/auth/web/password-auth#errors
function mapAuthError(code: string): string {
  switch (code) {
    case 'auth/email-already-in-use':
      return 'An account with this email already exists.';
    case 'auth/wrong-password':
    case 'auth/invalid-credential':
      // Both codes map to the same message — handles SDK v9 and v10+
      return 'Incorrect email or password.';
    case 'auth/user-not-found':
      return 'No account found with this email.';
    case 'auth/weak-password':
      return 'Password must be at least 6 characters.';
    case 'auth/invalid-email':
      return 'Please enter a valid email address.';
    case 'auth/too-many-requests':
      return 'Too many attempts. Please try again later.';
    default:
      return 'Something went wrong. Please try again.';
  }
}
```

No additional changes needed — this file is self-contained.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -20

    # Verify AuthProvider and useAuth are exported
    grep "export function AuthProvider\|export function useAuth" src/context/AuthContext.tsx

    # Verify onAuthStateChanged subscription returns cleanup function
    grep "return unsubscribe" src/context/AuthContext.tsx

    # Verify both legacy and modern error codes handled
    grep "auth/wrong-password\|auth/invalid-credential" src/context/AuthContext.tsx

    # Verify isLoading starts true (not false)
    grep "useState(true)" src/context/AuthContext.tsx
    ```
    TypeScript clean. All greps return matches.
  </verify>
  <done>
    - `AuthProvider` and `useAuth` exported from `src/context/AuthContext.tsx`
    - `isLoading` starts as `true`, set to `false` after first `onAuthStateChanged` fires
    - `onAuthStateChanged` subscription cleanup returned from `useEffect`
    - `mapAuthError` handles both `auth/wrong-password` and `auth/invalid-credential`
    - `signIn`, `signUp` return `{ error?: string }` — never throw to the caller
    - `signOut` calls `firebaseSignOut(auth)` — `onAuthStateChanged` sets user to null automatically
    - TypeScript passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire root layout with combined auth + onboarding gate, add auth modal screen, and deploy Firestore security rules</name>
  <files>
    app/_layout.tsx
    app/auth.tsx
    firestore.rules
  </files>
  <action>
**Part A: Update app/_layout.tsx**

Read the current `app/_layout.tsx` (from Phase 3 plan 03-03). It currently:
- Calls `SplashScreen.preventAutoHideAsync()` at module level
- Uses a `useEffect` to check `AsyncStorage.getItem('has_seen_onboarding')` and calls `router.replace`
- Calls `SplashScreen.hideAsync()` after the check
- Returns `null` while not ready, then renders the Stack

Phase 5 must add:
1. Wrap the entire layout in `AuthProvider`
2. Coordinate auth `isLoading` with the existing onboarding readiness check
3. Add an `auth` modal screen to the Stack declaration

The approach: split into `RootLayoutInner` (uses `useAuth`) and `RootLayout` (wraps with `AuthProvider`). This avoids calling `useAuth()` outside the provider.

```typescript
import { Stack, router } from 'expo-router';
import { useEffect, useState } from 'react';
import * as SplashScreen from 'expo-splash-screen';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { AuthProvider, useAuth } from '@/src/context/AuthContext';

// MUST be at module level — called before any component renders
SplashScreen.preventAutoHideAsync();

const ONBOARDING_KEY = 'has_seen_onboarding';

function RootLayoutInner() {
  const { isLoading: authIsLoading } = useAuth();
  const [hasCheckedOnboarding, setHasCheckedOnboarding] = useState(false);

  useEffect(() => {
    async function checkOnboarding() {
      try {
        const seen = await AsyncStorage.getItem(ONBOARDING_KEY);
        if (seen) {
          router.replace('/(tabs)');
        } else {
          router.replace('/(onboarding)');
        }
      } catch {
        router.replace('/(tabs)');
      } finally {
        setHasCheckedOnboarding(true);
      }
    }
    checkOnboarding();
  }, []);

  // CRITICAL: Both auth init AND onboarding check must complete before hiding splash.
  // Auth init: onAuthStateChanged fires (typically 50-500ms after app open).
  // Onboarding check: AsyncStorage read (fast, ~10ms).
  // Combined gate prevents: (1) flash of wrong auth state, (2) routing before onboarding known.
  // Research pitfall 5: if either resolves independently, the other causes a brief wrong-state flash.
  const isReady = !authIsLoading && hasCheckedOnboarding;

  useEffect(() => {
    if (isReady) {
      SplashScreen.hideAsync();
    }
  }, [isReady]);

  if (!isReady) {
    return null; // Splash screen still visible
  }

  return (
    <Stack>
      <Stack.Screen name="(onboarding)" options={{ headerShown: false }} />
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      <Stack.Screen
        name="player"
        options={{
          headerShown: false,
          presentation: 'fullScreenModal',
          animation: 'fade',
        }}
      />
      {/* Auth modal — reachable from Settings, not forced on any route */}
      <Stack.Screen
        name="auth"
        options={{
          headerShown: false,
          presentation: 'modal',
        }}
      />
    </Stack>
  );
}

export default function RootLayout() {
  return (
    <AuthProvider>
      <RootLayoutInner />
    </AuthProvider>
  );
}
```

IMPORTANT: Preserve any other content in the existing `_layout.tsx` that is NOT the onboarding check or the Stack declaration. Read the file first, then merge. Do not remove imports or logic added by prior plans that is not being replaced.

**Part B: Create app/auth.tsx**

The auth screen is a modal (presented from Settings). Single form with Sign In / Sign Up toggle. Email + password only. No email verification (deferred per locked decision). No Forgot Password row (outside scope for this phase).

```typescript
// app/auth.tsx
// Modal auth screen — presented via router.push('/auth') from Settings.
// Single form with Sign In / Sign Up toggle. No forced auth anywhere in the app.
// On success: router.back() dismisses the modal; useFavoritesSync fires automatically
// via onAuthStateChanged in AuthContext (implemented in Plan 02).

import { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  SafeAreaView,
  ActivityIndicator,
} from 'react-native';
import { router } from 'expo-router';
import { useAuth } from '@/src/context/AuthContext';

type Mode = 'signin' | 'signup';

export default function AuthScreen() {
  const [mode, setMode] = useState<Mode>('signin');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { signIn, signUp } = useAuth();

  const handleSubmit = async () => {
    if (!email.trim() || !password.trim()) {
      setError('Please enter your email and password.');
      return;
    }
    setIsSubmitting(true);
    setError(null);

    const action = mode === 'signin' ? signIn : signUp;
    const result = await action(email.trim(), password);

    setIsSubmitting(false);
    if (result.error) {
      setError(result.error);
    } else {
      // Success — dismiss modal. useFavoritesSync (Plan 02) reacts to onAuthStateChanged
      // and runs migration + Firestore load silently in the background.
      router.back();
    }
  };

  const toggleMode = () => {
    setMode((m) => (m === 'signin' ? 'signup' : 'signin'));
    setError(null);
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        style={styles.inner}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.title}>
            {mode === 'signin' ? 'Welcome back' : 'Create account'}
          </Text>
          <Text style={styles.subtitle}>
            {mode === 'signin'
              ? 'Sign in to sync your favorites'
              : 'Save your favorites across devices'}
          </Text>
        </View>

        {/* Form */}
        <View style={styles.form}>
          <TextInput
            style={styles.input}
            value={email}
            onChangeText={setEmail}
            placeholder="Email"
            placeholderTextColor="rgba(255,255,255,0.35)"
            autoCapitalize="none"
            keyboardType="email-address"
            autoComplete="email"
            textContentType="emailAddress"
          />
          <TextInput
            style={styles.input}
            value={password}
            onChangeText={setPassword}
            placeholder="Password"
            placeholderTextColor="rgba(255,255,255,0.35)"
            secureTextEntry
            autoComplete={mode === 'signup' ? 'new-password' : 'current-password'}
            textContentType={mode === 'signup' ? 'newPassword' : 'password'}
          />

          {error && <Text style={styles.errorText}>{error}</Text>}

          <Pressable
            style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
            onPress={handleSubmit}
            disabled={isSubmitting}
          >
            {isSubmitting ? (
              <ActivityIndicator color="#ffffff" />
            ) : (
              <Text style={styles.submitText}>
                {mode === 'signin' ? 'Sign In' : 'Create Account'}
              </Text>
            )}
          </Pressable>
        </View>

        {/* Toggle mode */}
        <Pressable onPress={toggleMode} style={styles.toggleRow}>
          <Text style={styles.toggleText}>
            {mode === 'signin'
              ? "Don't have an account? "
              : 'Already have an account? '}
            <Text style={styles.toggleLink}>
              {mode === 'signin' ? 'Sign up' : 'Sign in'}
            </Text>
          </Text>
        </Pressable>

        {/* Dismiss without auth */}
        <Pressable onPress={() => router.back()} style={styles.skipRow}>
          <Text style={styles.skipText}>Continue without account</Text>
        </Pressable>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0f1115',
  },
  inner: {
    flex: 1,
    paddingHorizontal: 24,
    paddingTop: 40,
    justifyContent: 'center',
  },
  header: {
    marginBottom: 40,
    alignItems: 'center',
  },
  title: {
    color: '#ffffff',
    fontSize: 28,
    fontWeight: '600',
    marginBottom: 8,
  },
  subtitle: {
    color: 'rgba(255,255,255,0.5)',
    fontSize: 15,
    textAlign: 'center',
  },
  form: {
    gap: 12,
    marginBottom: 24,
  },
  input: {
    backgroundColor: 'rgba(255,255,255,0.08)',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.12)',
    paddingHorizontal: 16,
    paddingVertical: 14,
    color: '#ffffff',
    fontSize: 16,
  },
  errorText: {
    color: '#ef4444',
    fontSize: 14,
    textAlign: 'center',
  },
  submitButton: {
    backgroundColor: '#8b5cf6',
    borderRadius: 14,
    height: 52,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 4,
  },
  submitButtonDisabled: {
    opacity: 0.6,
  },
  submitText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  toggleRow: {
    alignItems: 'center',
    marginBottom: 16,
  },
  toggleText: {
    color: 'rgba(255,255,255,0.5)',
    fontSize: 14,
  },
  toggleLink: {
    color: '#8b5cf6',
    fontWeight: '600',
  },
  skipRow: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  skipText: {
    color: 'rgba(255,255,255,0.3)',
    fontSize: 13,
  },
});
```

**Part C: Create firestore.rules**

Create `firestore.rules` at the project root. These rules ensure each user can only read/write their own favorites document. No authenticated user can access another user's data. Unauthenticated users are denied entirely.

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // User favorites document: users/{uid}
    // Allow read and write only for the authenticated user whose uid matches the document uid.
    // This prevents any user from reading or writing another user's favorites.
    // Covers: getFavorites, setFavorites, migrateLocalToCloud operations in FavoritesService.
    match /users/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }
  }
}
```

After writing the file, deploy the rules to Firebase using the Firebase CLI. If the CLI is not installed or not authenticated, note this in the output — the executor should run:
```bash
# Check if Firebase CLI is available
firebase --version 2>/dev/null || echo "Firebase CLI not installed"

# Deploy rules if CLI available and authenticated
firebase deploy --only firestore:rules --project $(grep EXPO_PUBLIC_FIREBASE_PROJECT_ID .env | cut -d= -f2 | tr -d '"') 2>/dev/null || echo "Rules written to firestore.rules — deploy manually: firebase deploy --only firestore:rules"
```

The rules file on disk is the source of truth. If the CLI is not available, the executor must note that rules deployment is a pending manual step.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -20

    # Verify AuthProvider wraps layout
    grep "AuthProvider" app/_layout.tsx

    # Verify combined isReady gate
    grep "authIsLoading\|hasCheckedOnboarding" app/_layout.tsx

    # Verify auth modal screen declared in Stack
    grep "auth" app/_layout.tsx | grep "Stack.Screen"

    # Verify auth.tsx exists with correct exports
    grep "export default function AuthScreen" app/auth.tsx

    # Verify auth screen calls router.back() on success
    grep "router.back" app/auth.tsx

    # Verify firestore.rules exists with uid check
    grep "request.auth.uid == uid" firestore.rules

    # Verify no forced auth redirects exist anywhere (auth is optional)
    grep -rn "Stack.Protected\|redirect.*auth\|requiresAuth" app/ src/ --include="*.tsx" --include="*.ts" 2>/dev/null && echo "WARNING: forced auth found" || echo "OK: auth is optional"
    ```
    TypeScript clean. All greps return matches. No forced auth patterns found.
  </verify>
  <done>
    - `app/_layout.tsx` wraps in `AuthProvider`; `RootLayoutInner` uses `useAuth().isLoading` in combined isReady gate
    - Splash screen hidden only when both `!authIsLoading` AND `hasCheckedOnboarding` are true
    - Stack declares `auth` screen with `presentation: 'modal'`
    - `app/auth.tsx` renders email/password form with Sign In / Sign Up toggle
    - `app/auth.tsx` calls `router.back()` on successful auth
    - `app/auth.tsx` shows human-readable error messages (from `mapAuthError` via `useAuth`)
    - `firestore.rules` restricts `users/{uid}` read/write to `request.auth.uid == uid`
    - No route forces authentication — all screens accessible without account
    - TypeScript passes with no errors
  </done>
</task>

</tasks>

<verification>
After all three tasks complete:

```bash
cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

# Full TypeScript check — must be clean
npx tsc --noEmit

# Auth initialization
grep "getReactNativePersistence\|initializeAuth" src/lib/firebase.ts

# Both auth exports present
grep "export.*auth\|export.*db" src/lib/firebase.ts

# AuthProvider is the outermost wrapper in layout
grep -A5 "export default function RootLayout" app/_layout.tsx

# Combined isReady gate
grep "isReady\|authIsLoading\|hasCheckedOnboarding" app/_layout.tsx | head -10

# Auth modal screen in Stack
grep -A3 "name=\"auth\"" app/_layout.tsx

# Auth screen form elements
grep "TextInput\|signIn\|signUp\|router.back" app/auth.tsx | head -10

# Security rules user isolation
cat firestore.rules
```
</verification>

<success_criteria>
- `src/lib/firebase.ts` exports `auth` initialized with `initializeAuth` + `getReactNativePersistence(AsyncStorage)` — not bare `getAuth`
- `src/lib/firebase.ts` exports `db` from `getFirestore(app)`
- `src/context/AuthContext.tsx` exports `AuthProvider` and `useAuth` with full auth API
- `app/_layout.tsx` wraps in `AuthProvider`; splash held until both auth init AND onboarding check complete
- `app/auth.tsx` is a modal screen with email/password Sign In / Sign Up form; dismisses on success
- `firestore.rules` contains `request.auth.uid == uid` rule protecting `users/{uid}` documents
- `npx tsc --noEmit` exits 0 across all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/05-auth-and-cloud-sync/05-01-SUMMARY.md` documenting:
- firebase.ts changes: what was changed from Phase 1 scaffold and why (initializeAuth vs getAuth)
- How the re-initialization guard works (try/catch or getApps() — whichever was used)
- AuthContext: shape of AuthContextValue, why React Context not Zustand for auth
- Root layout gate: how isReady combines auth + onboarding (especially if Phase 3 implementation differed from plan)
- auth.tsx: any UX deviations from the plan
- Firestore rules: whether CLI deploy succeeded or is pending manual step
- Any TypeScript issues encountered (especially getReactNativePersistence type definitions) and how resolved
</output>
