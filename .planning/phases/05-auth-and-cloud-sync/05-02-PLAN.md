---
phase: 05-auth-and-cloud-sync
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/services/FavoritesService.ts
  - src/hooks/useFavoritesSync.ts
  - app/_layout.tsx
autonomous: true
requirements:
  - AUTH-02
  - AUTH-03
  - FAV-03

must_haves:
  truths:
    - "On login, cloud favorites are loaded from the Supabase favorites table and replace the Zustand store contents"
    - "On logout, Zustand store reverts to local favorites (kept in-place from before login — not cleared)"
    - "useFavoritesSync runs in the root layout (never unmounts) so the migration ref does not reset on navigation"
    - "Supabase reads fail silently — local favorites remain unchanged if Supabase is unreachable"
    - "FavoritesService.getFavorites queries the favorites table by user_id and returns Favorite[]"
    - "FavoritesService.setFavorites upserts Favorite[] rows into the favorites table keyed by (user_id, sound_id)"
    - "migrateLocalToCloud merges local favorites into Supabase favorites (dedup by sound_id) and returns the merged set"
  artifacts:
    - path: "src/services/FavoritesService.ts"
      provides: "Static class with getFavorites(uid), setFavorites(uid, favorites), migrateLocalToCloud(uid, localFavorites)"
      exports: ["FavoritesService"]
      min_lines: 50
    - path: "src/hooks/useFavoritesSync.ts"
      provides: "Hook: on user login runs migration then loads from Supabase; on logout leaves local store intact; hasMigrated ref prevents double-migration"
      exports: ["useFavoritesSync"]
    - path: "app/_layout.tsx"
      provides: "useFavoritesSync() called in RootLayoutInner — persists across all navigation"
  key_links:
    - from: "src/hooks/useFavoritesSync.ts"
      to: "src/services/FavoritesService.ts"
      via: "FavoritesService.migrateLocalToCloud(user.id, favorites)"
      pattern: "migrateLocalToCloud"
    - from: "src/hooks/useFavoritesSync.ts"
      to: "src/stores/favoritesStore.ts"
      via: "useFavoritesStore() setFavorites call after Supabase load"
      pattern: "setFavorites"
    - from: "src/hooks/useFavoritesSync.ts"
      to: "src/context/AuthContext.tsx"
      via: "useAuth().user — effect depends on user?.id"
      pattern: "user\\.id"
    - from: "app/_layout.tsx"
      to: "src/hooks/useFavoritesSync.ts"
      via: "useFavoritesSync() call in RootLayoutInner"
      pattern: "useFavoritesSync"
    - from: "src/services/FavoritesService.ts"
      to: "src/lib/supabase.ts"
      via: "supabase import; .from('favorites').select() / .upsert()"
      pattern: "from\\('favorites'\\)"
---

<objective>
Build the Supabase favorites sync layer: FavoritesService (read/write to the Supabase favorites table), useFavoritesSync hook (auth-state-driven sync logic), and wire the hook into the root layout so sync triggers on login/logout without any user-facing loading state.

Purpose: Plan 01 established auth state. This plan makes auth state drive favorites state — the core value of the feature. When a user logs in, their favorites update from Supabase silently. When they log out, local favorites stay in place.
Output: FavoritesService (Supabase data layer), useFavoritesSync hook (sync orchestration), root layout wired to call the hook.

Note: Using Supabase as source of truth per locked user decision. FavoritesService queries the existing `favorites` table from Phase 3 using `@supabase/supabase-js`. No Firestore, no Firebase.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-auth-and-cloud-sync/05-01-SUMMARY.md
@src/stores/favoritesStore.ts
@src/services/LocalFavoritesAdapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FavoritesService — Supabase table read, write, and migration</name>
  <files>
    src/services/FavoritesService.ts
  </files>
  <action>
Create `src/services/FavoritesService.ts`. This service is the only layer that talks to Supabase for favorites data. It handles three operations: reading favorites from the Supabase favorites table, writing favorites to Supabase, and the one-shot migration from local to cloud.

Per locked user decision: Supabase is the source of truth. On login, merge and push. On load, pull from Supabase if authenticated.

**Supabase favorites table schema (from Phase 3):**
```
Table: favorites
Columns:
  - id: uuid (primary key, generated)
  - user_id: uuid (references auth.users, not null)
  - sound_id: text (the sound identifier, e.g. 'rain-01', not null)
  - added_at: timestamptz (when favorited, defaults to now())
Constraint: unique(user_id, sound_id) — natural deduplication by sound_id per user
```

**Why upsert (not insert):** The `unique(user_id, sound_id)` constraint means inserting the same sound twice throws a duplicate key error. Using `upsert` (insert with `onConflict: 'user_id,sound_id'`) handles deduplication at the database level — exactly what we need for migration merge.

```typescript
// src/services/FavoritesService.ts
//
// Supabase data layer for favorites sync.
// Table: favorites
// Schema: id (uuid pk), user_id (uuid), sound_id (text), added_at (timestamptz)
// Unique constraint: (user_id, sound_id) — natural deduplication.
//
// Per locked user decision: Supabase is source of truth after login.
// On login: merge local → Supabase (dedup by sound_id), then return merged set.
// On load: select from favorites where user_id = uid.
//
// No Firestore, no Firebase. Using @supabase/supabase-js only.

import { supabase } from '@/src/lib/supabase';
import type { Favorite } from '@/src/types';

export class FavoritesService {
  /**
   * Reads the current cloud favorites for a user from the Supabase favorites table.
   * Returns empty array if no rows found.
   * Does NOT throw — caller handles gracefully.
   */
  static async getFavorites(uid: string): Promise<Favorite[]> {
    const { data, error } = await supabase
      .from('favorites')
      .select('sound_id, added_at')
      .eq('user_id', uid)
      .order('added_at', { ascending: false });

    if (error || !data) return [];

    return data.map((row) => ({
      id: row.sound_id,
      // added_at is a timestamptz string from Supabase — convert to ms timestamp
      addedAt: new Date(row.added_at).getTime(),
    }));
  }

  /**
   * Writes (upserts) the full favorites set to Supabase for a user.
   * Uses upsert with onConflict: 'user_id,sound_id' so duplicate sound_ids
   * update the existing row rather than inserting a duplicate.
   * merge: true preserves the row; we update added_at to keep the earliest timestamp.
   */
  static async setFavorites(uid: string, favorites: Favorite[]): Promise<void> {
    if (favorites.length === 0) return;

    const rows = favorites.map((fav) => ({
      user_id: uid,
      sound_id: fav.id,
      // Convert ms timestamp back to ISO string for Supabase timestamptz
      added_at: new Date(fav.addedAt).toISOString(),
    }));

    const { error } = await supabase
      .from('favorites')
      .upsert(rows, {
        onConflict: 'user_id,sound_id',
        // ignoreDuplicates: false means we update on conflict (update added_at)
        ignoreDuplicates: false,
      });

    if (error) throw error; // Propagate to caller (useFavoritesSync catches silently)
  }

  /**
   * Migrates local favorites to the cloud account on first login.
   *
   * Algorithm:
   *   1. Read existing cloud favorites from Supabase
   *   2. Build a merged map: cloud favorites first, then overlay local favorites
   *      - If the same sound exists in both: keep the EARLIER addedAt timestamp
   *        (preserves when the user first saved it, regardless of which device)
   *   3. Write the merged set back to Supabase via upsert (dedup by sound_id)
   *   4. Return the merged Favorite[] so the caller can update the Zustand store
   *
   * This runs once per login session (enforced by useFavoritesSync's hasMigrated ref).
   * If it fails, the exception propagates to useFavoritesSync which catches and ignores it —
   * local favorites remain intact as the fallback (locked decision: silent failure).
   */
  static async migrateLocalToCloud(
    uid: string,
    localFavorites: Favorite[]
  ): Promise<Favorite[]> {
    // 1. Read current cloud favorites
    const cloudFavorites = await FavoritesService.getFavorites(uid);

    // 2. Build merged map — cloud first, then local (earlier addedAt wins)
    const merged: Record<string, Favorite> = {};

    for (const fav of cloudFavorites) {
      merged[fav.id] = fav;
    }

    for (const fav of localFavorites) {
      if (!merged[fav.id] || fav.addedAt < merged[fav.id].addedAt) {
        // Local entry is earlier (or cloud doesn't have this sound) — use local
        merged[fav.id] = fav;
      }
      // else: cloud entry is older — keep cloud entry (already in merged)
    }

    const mergedArray = Object.values(merged);

    // 3. Write merged set to Supabase (upsert handles dedup by sound_id constraint)
    await FavoritesService.setFavorites(uid, mergedArray);

    // 4. Return merged array so caller can update Zustand store
    return mergedArray;
  }
}
```
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -20

    # Verify class and method exports
    grep "export class FavoritesService\|static async getFavorites\|static async setFavorites\|static async migrateLocalToCloud" src/services/FavoritesService.ts

    # Verify Supabase queries (not Firestore)
    grep "from('favorites')\|\.select\|\.upsert\|\.eq('user_id'" src/services/FavoritesService.ts

    # Verify upsert with onConflict (dedup by sound_id)
    grep "onConflict\|upsert" src/services/FavoritesService.ts

    # Verify no Firebase/Firestore imports
    grep "firebase\|Firebase\|doc(\|getDoc\|setDoc\|getFirestore" src/services/FavoritesService.ts && echo "ERROR: Firebase found" || echo "OK: no Firebase"

    # Verify supabase import from lib
    grep "from.*lib/supabase\|import.*supabase" src/services/FavoritesService.ts
    ```
    TypeScript clean. All greps return matches. No Firebase references.
  </verify>
  <done>
    - `FavoritesService` exported as class with three static methods: `getFavorites`, `setFavorites`, `migrateLocalToCloud`
    - `getFavorites` queries `favorites` table by `user_id`, returns `Favorite[]` — empty array if no rows (no throw)
    - `setFavorites` upserts rows using `onConflict: 'user_id,sound_id'` for deduplication
    - `migrateLocalToCloud` merges cloud + local, keeps earliest `addedAt` for duplicates, writes merged set, returns merged array
    - No Firebase or Firestore imports — uses `supabase.from('favorites')` exclusively
    - TypeScript passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useFavoritesSync hook and wire into root layout</name>
  <files>
    src/hooks/useFavoritesSync.ts
    app/_layout.tsx
  </files>
  <action>
**Part A: Create src/hooks/useFavoritesSync.ts**

This hook orchestrates the auth-state-driven favorites sync. It listens to `user.id` changes and:
- On login: runs migration (once per session) then loads Supabase favorites
- On logout: does nothing — local favorites remain in Zustand store as-is

**Critical placement rule:** This hook MUST be called in the root layout (which never unmounts), NOT in a tab screen or any component that can unmount. If called in a component that unmounts, the `hasMigrated` ref resets on remount and migration runs again.

Note: Supabase User uses `.id` (not `.uid`) for the user ID field. The effect dependency is `user?.id`.

```typescript
// src/hooks/useFavoritesSync.ts
//
// Auth-state-driven favorites sync.
//
// On login:
//   1. Runs FavoritesService.migrateLocalToCloud ONCE per session (hasMigrated ref)
//   2. Updates Zustand store with merged favorites from Supabase
//
// On logout:
//   - Does nothing — local favorites stay in Zustand store as the fallback
//   - This is intentional: favorites are not "logged-in data"; they were local before auth.
//     Keeping them on logout avoids "where did my favorites go?" confusion.
//
// Failure mode:
//   - Any Supabase error is caught silently — local favorites remain unchanged.
//   - hasMigrated.current resets to false on next app open (ref is in-memory).
//     This means failed migration retries on the next login.
//
// IMPORTANT: Call this hook in the root layout ONLY. If called in a component that
// can unmount/remount (e.g., a tab screen), hasMigrated.current resets on remount
// and migration runs again.
//
// Note: Supabase User uses .id (not .uid) for the user identifier.

import { useEffect, useRef } from 'react';
import { useAuth } from '@/src/context/AuthContext';
import { useFavoritesStore } from '@/src/stores/favoritesStore';
import { FavoritesService } from '@/src/services/FavoritesService';

export function useFavoritesSync(): void {
  const { user } = useAuth();
  const favorites = useFavoritesStore((s) => s.favorites);
  const setFavorites = useFavoritesStore((s) => s.setFavorites);
  // Ref (not state) — prevents double-migration on re-renders; resets on app restart.
  const hasMigrated = useRef(false);

  useEffect(() => {
    if (!user) {
      // User logged out or was never logged in.
      // Local favorites stay as-is — do not clear Zustand store on logout.
      return;
    }

    // User is logged in — sync favorites from Supabase.
    async function syncOnLogin() {
      try {
        if (!hasMigrated.current) {
          // First login this session: run migration (merge local → Supabase, dedup by sound_id).
          // Migration is SILENT — no loading indicator (locked decision).
          hasMigrated.current = true;
          const mergedFavorites = await FavoritesService.migrateLocalToCloud(
            user!.id, // Supabase uses .id (not .uid)
            favorites
          );
          setFavorites(mergedFavorites);
        } else {
          // Already migrated this session (e.g., app came back from background).
          // Just load from Supabase.
          const cloudFavorites = await FavoritesService.getFavorites(user!.id);
          setFavorites(cloudFavorites);
        }
      } catch (error) {
        // Silent failure — local favorites remain unchanged (locked decision).
        // Migration retries on next app open (hasMigrated resets at app restart).
        console.warn('[useFavoritesSync] Sync failed silently:', error);
      }
    }

    syncOnLogin();
  }, [user?.id]); // Re-runs only when the user ID changes (login / account switch)
  // Note: favorites and setFavorites are intentionally omitted from deps array.
  // favorites is read once at login time for migration — we don't want the effect
  // to re-run every time favorites changes (that would cause sync loops).
}
```

**Part B: Update app/_layout.tsx**

Read the current `app/_layout.tsx` (modified in Plan 01 to include AuthProvider and combined isReady gate). Add `useFavoritesSync()` call inside `RootLayoutInner`.

The hook call must be inside `RootLayoutInner` (which is inside `AuthProvider`) so `useAuth()` is available. It must NOT be in `RootLayout` itself (which wraps the provider).

Add after the existing state declarations in `RootLayoutInner`:

```typescript
// Import at top of file (add to existing imports):
import { useFavoritesSync } from '@/src/hooks/useFavoritesSync';

// Inside RootLayoutInner, after existing state/hooks:
// Call favorites sync hook here — root layout never unmounts, ensuring
// hasMigrated ref persists across all navigation.
useFavoritesSync();
```

The rest of `RootLayoutInner` is unchanged. Do not modify the isReady gate, onboarding check, or Stack declaration.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -20

    # Verify hook exports
    grep "export function useFavoritesSync" src/hooks/useFavoritesSync.ts

    # Verify hasMigrated ref (not useState)
    grep "useRef.*false\|hasMigrated" src/hooks/useFavoritesSync.ts

    # Verify effect depends on user?.id (Supabase uses .id not .uid)
    grep "user\?\.id\|user\.id" src/hooks/useFavoritesSync.ts

    # Verify silent failure (try/catch with console.warn)
    grep "console.warn\|catch" src/hooks/useFavoritesSync.ts

    # Verify hook is called in root layout
    grep "useFavoritesSync" app/_layout.tsx

    # Verify hook import in layout
    grep "import.*useFavoritesSync" app/_layout.tsx

    # Verify no Firebase references in new files
    grep "firebase\|Firebase\|Firestore\|doc(\|getDoc\|setDoc" src/hooks/useFavoritesSync.ts && echo "WARNING: Firebase found" || echo "OK: no Firebase"
    ```
    TypeScript clean. All greps return matches. No Firebase references.
  </verify>
  <done>
    - `useFavoritesSync` exported from `src/hooks/useFavoritesSync.ts`
    - `hasMigrated` is a `useRef(false)` — not state (does not trigger re-renders)
    - Effect depends on `user?.id` (Supabase User field) — runs on login/logout, not on every favorites change
    - Migration failure is caught silently with `console.warn` — local store unchanged
    - `useFavoritesSync()` called in `RootLayoutInner` in `app/_layout.tsx`
    - On login: migration runs once, then `setFavorites` called with merged/cloud data
    - On logout: no action taken, local favorites remain in store
    - No Firebase or Firestore references
    - TypeScript passes with no errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

# Full TypeScript check
npx tsc --noEmit

# FavoritesService: all three methods present
grep "static async getFavorites\|static async setFavorites\|static async migrateLocalToCloud" src/services/FavoritesService.ts

# FavoritesService: Supabase queries (not Firestore)
grep "from('favorites')\|upsert\|onConflict" src/services/FavoritesService.ts

# useFavoritesSync: key patterns
grep "hasMigrated\|user\?\.id\|console.warn\|migrateLocalToCloud\|setFavorites" src/hooks/useFavoritesSync.ts

# Root layout calls hook
grep "useFavoritesSync" app/_layout.tsx

# No Firebase in Phase 5 sync files
grep -rn "firebase\|getDoc\|setDoc\|doc(db\|arrayUnion" src/services/FavoritesService.ts src/hooks/useFavoritesSync.ts && echo "WARNING: Firebase found" || echo "OK: Supabase only"
```
</verification>

<success_criteria>
- `FavoritesService` has `getFavorites`, `setFavorites`, `migrateLocalToCloud` as static methods
- Supabase favorites stored and retrieved via `supabase.from('favorites').select()` / `.upsert()`
- `useFavoritesSync` hook uses `useRef(false)` for migration guard (not state)
- Hook effect depends only on `user?.id` (Supabase User field) — does not loop on favorites changes
- `useFavoritesSync()` called in `RootLayoutInner` (root layout, never unmounts)
- Sync failures are caught silently — local store unchanged on Supabase error
- No Firebase or Firestore imports anywhere in this plan's files
- `npx tsc --noEmit` exits 0 across all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/05-auth-and-cloud-sync/05-02-SUMMARY.md` documenting:
- FavoritesService: Supabase table queries used (select, upsert), how onConflict handles dedup
- migrateLocalToCloud: which timestamp wins on conflict and why (earliest addedAt)
- useFavoritesSync: why useRef not useState for hasMigrated, why user?.id (not user?.uid) in deps
- Root layout wiring: where exactly in RootLayoutInner the hook is called
- Any TypeScript issues or import path adjustments needed
- Whether any deviations from this plan were made and why
</output>
