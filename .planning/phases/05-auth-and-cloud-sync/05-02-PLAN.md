---
phase: 05-auth-and-cloud-sync
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/services/FavoritesService.ts
  - src/hooks/useFavoritesSync.ts
  - app/_layout.tsx
autonomous: true
requirements:
  - AUTH-03

must_haves:
  truths:
    - "On login, cloud favorites are loaded from Firestore and replace the Zustand store contents"
    - "On logout, Zustand store reverts to local favorites (kept in-place from before login — not cleared)"
    - "useFavoritesSync runs in the root layout (never unmounts) so the migration ref does not reset on navigation"
    - "Firestore reads fail silently — local favorites remain unchanged if Firestore is unreachable"
    - "FavoritesService.getFavorites reads Firestore users/{uid} and returns Favorite[] from the favorites map"
    - "FavoritesService.setFavorites writes Favorite[] as a map keyed by soundId with setDoc merge:true"
  artifacts:
    - path: "src/services/FavoritesService.ts"
      provides: "Static class with getFavorites(uid), setFavorites(uid, favorites), migrateLocalToCloud(uid, localFavorites)"
      exports: ["FavoritesService"]
      min_lines: 50
    - path: "src/hooks/useFavoritesSync.ts"
      provides: "Hook: on user login runs migration then loads from Firestore; on logout leaves local store intact; hasMigrated ref prevents double-migration"
      exports: ["useFavoritesSync"]
    - path: "app/_layout.tsx"
      provides: "useFavoritesSync() called in RootLayoutInner — persists across all navigation"
  key_links:
    - from: "src/hooks/useFavoritesSync.ts"
      to: "src/services/FavoritesService.ts"
      via: "FavoritesService.migrateLocalToCloud(user.uid, favorites)"
      pattern: "migrateLocalToCloud"
    - from: "src/hooks/useFavoritesSync.ts"
      to: "src/stores/favoritesStore.ts"
      via: "useFavoritesStore() setFavorites call after Firestore load"
      pattern: "setFavorites"
    - from: "src/hooks/useFavoritesSync.ts"
      to: "src/context/AuthContext.tsx"
      via: "useAuth().user — effect depends on user?.uid"
      pattern: "user\\.uid"
    - from: "app/_layout.tsx"
      to: "src/hooks/useFavoritesSync.ts"
      via: "useFavoritesSync() call in RootLayoutInner"
      pattern: "useFavoritesSync"
    - from: "src/services/FavoritesService.ts"
      to: "src/lib/firebase.ts"
      via: "db import; doc(db, 'users', uid) path"
      pattern: "doc\\(db"
---

<objective>
Build the Firestore favorites sync layer: FavoritesService (read/write to Firestore), useFavoritesSync hook (auth-state-driven sync logic), and wire the hook into the root layout so sync triggers on login/logout without any user-facing loading state.

Purpose: Plan 01 established auth state. This plan makes auth state drive favorites state — the core value of the feature. When a user logs in, their favorites update from Firestore silently. When they log out, local favorites stay in place.
Output: FavoritesService (Firestore data layer), useFavoritesSync hook (sync orchestration), root layout wired to call the hook.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-auth-and-cloud-sync/05-RESEARCH.md
@.planning/phases/05-auth-and-cloud-sync/05-01-SUMMARY.md
@src/stores/favoritesStore.ts
@src/services/LocalFavoritesAdapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FavoritesService — Firestore read, write, and migration</name>
  <files>
    src/services/FavoritesService.ts
  </files>
  <action>
Create `src/services/FavoritesService.ts`. This service is the only layer that talks to Firestore. It handles three operations: reading favorites from Firestore, writing favorites to Firestore, and the one-shot migration from local to cloud.

**Critical data model choice:** Firestore favorites are stored as a MAP (not array) at `users/{uid}.favorites`. The key is `soundId`, the value is `{ addedAt: number }`. This structure naturally deduplicates — if the same sound exists in both local and cloud, the map key collision means only one entry exists. `setDoc` with `merge: true` merges at the object level without overwriting unrelated fields in the user document.

Why NOT an array: `arrayUnion` cannot deduplicate by partial object equality — two `{ id: 'rain-01', addedAt: ... }` objects with different timestamps are treated as distinct array elements. Research confirmed this (firebase-js-sdk issue #1918).

```typescript
// src/services/FavoritesService.ts
//
// Firestore data layer for favorites sync.
// Data model: users/{uid} document with favorites field as a map keyed by soundId.
//   { favorites: { "rain-01": { addedAt: 1707000000000 }, "fire-02": { addedAt: ... } } }
//
// Why a map (not array): arrayUnion does NOT deduplicate objects by partial field equality.
// A map keyed by soundId is naturally deduplicated — two entries with the same soundId
// always collapse to one. setDoc({ merge: true }) merges at the map level.
// Source: https://firebase.google.com/docs/firestore/manage-data/add-data
// Source: firebase-js-sdk issue #1918 — arrayUnion object dedup limitation confirmed

import { doc, getDoc, setDoc } from 'firebase/firestore';
import { db } from '@/src/lib/firebase';
import type { Favorite, FavoritesMap } from '@/src/types';

const userDocRef = (uid: string) => doc(db, 'users', uid);

export class FavoritesService {
  /**
   * Reads the current cloud favorites for a user.
   * Returns empty array if document does not exist or has no favorites field.
   * Does NOT throw — caller handles gracefully.
   */
  static async getFavorites(uid: string): Promise<Favorite[]> {
    const snap = await getDoc(userDocRef(uid));
    if (!snap.exists()) return [];
    const data = snap.data();
    if (!data?.favorites) return [];
    const map = data.favorites as FavoritesMap;
    return Object.entries(map).map(([id, { addedAt }]) => ({ id, addedAt }));
  }

  /**
   * Writes the full favorites set to Firestore for a user.
   * Converts Favorite[] to a map keyed by soundId before writing.
   * merge: true preserves other fields in the user document (e.g. future profile data).
   */
  static async setFavorites(uid: string, favorites: Favorite[]): Promise<void> {
    const map: FavoritesMap = favorites.reduce<FavoritesMap>((acc, fav) => {
      acc[fav.id] = { addedAt: fav.addedAt };
      return acc;
    }, {});

    await setDoc(userDocRef(uid), { favorites: map }, { merge: true });
  }

  /**
   * Migrates local favorites to the cloud account on first login.
   *
   * Algorithm:
   *   1. Read existing cloud favorites
   *   2. Build a merged map: cloud favorites first, then overlay local favorites
   *      - If the same sound exists in both: keep the EARLIER addedAt timestamp
   *        (preserves when the user first saved it, regardless of which device)
   *   3. Write the merged set back to Firestore
   *   4. Return the merged Favorite[] so the caller can update the Zustand store
   *
   * This runs once per login session (enforced by useFavoritesSync's hasMigrated ref).
   * If it fails, the exception propagates to useFavoritesSync which catches and ignores it —
   * local favorites remain intact as the fallback (locked decision: silent failure).
   */
  static async migrateLocalToCloud(
    uid: string,
    localFavorites: Favorite[]
  ): Promise<Favorite[]> {
    // 1. Read current cloud favorites
    const cloudFavorites = await FavoritesService.getFavorites(uid);

    // 2. Build merged map — cloud first, then local (earlier addedAt wins)
    const merged: Record<string, Favorite> = {};

    for (const fav of cloudFavorites) {
      merged[fav.id] = fav;
    }

    for (const fav of localFavorites) {
      if (!merged[fav.id] || fav.addedAt < merged[fav.id].addedAt) {
        // Local entry is earlier (or cloud doesn't have this sound) — use local
        merged[fav.id] = fav;
      }
      // else: cloud entry is older — keep cloud entry (already in merged)
    }

    const mergedArray = Object.values(merged);

    // 3. Write merged set to Firestore
    await FavoritesService.setFavorites(uid, mergedArray);

    // 4. Return merged array so caller can update Zustand store
    return mergedArray;
  }
}
```
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -20

    # Verify class and method exports
    grep "export class FavoritesService\|static async getFavorites\|static async setFavorites\|static async migrateLocalToCloud" src/services/FavoritesService.ts

    # Verify map data model (not array)
    grep "FavoritesMap\|Record<string" src/services/FavoritesService.ts

    # Verify setDoc with merge:true
    grep "merge: true" src/services/FavoritesService.ts

    # Verify no arrayUnion usage
    grep "arrayUnion" src/services/FavoritesService.ts && echo "ERROR: arrayUnion used — use map instead" || echo "OK: no arrayUnion"

    # Verify db import from firebase.ts
    grep "from.*firebase\|import.*db" src/services/FavoritesService.ts
    ```
    TypeScript clean. All greps return matches. No arrayUnion.
  </verify>
  <done>
    - `FavoritesService` exported as class with three static methods: `getFavorites`, `setFavorites`, `migrateLocalToCloud`
    - `getFavorites` returns `Favorite[]` — empty array if document missing (no throw)
    - `setFavorites` converts `Favorite[]` to `FavoritesMap` and writes via `setDoc` with `merge: true`
    - `migrateLocalToCloud` merges cloud + local, keeps earliest `addedAt` for duplicates, writes merged set, returns merged array
    - No `arrayUnion` usage — map structure used throughout
    - TypeScript passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useFavoritesSync hook and wire into root layout</name>
  <files>
    src/hooks/useFavoritesSync.ts
    app/_layout.tsx
  </files>
  <action>
**Part A: Create src/hooks/useFavoritesSync.ts**

This hook orchestrates the auth-state-driven favorites sync. It listens to `user.uid` changes and:
- On login: runs migration (once per session) then loads Firestore favorites
- On logout: does nothing — local favorites remain in Zustand store as-is

**Critical placement rule:** This hook MUST be called in the root layout (which never unmounts), NOT in a tab screen or any component that can unmount. If called in a component that unmounts, the `hasMigrated` ref resets on remount and migration runs again — overwriting Firestore favorites with potentially stale local data (research pitfall 6).

```typescript
// src/hooks/useFavoritesSync.ts
//
// Auth-state-driven favorites sync.
//
// On login:
//   1. Runs FavoritesService.migrateLocalToCloud ONCE per session (hasMigrated ref)
//   2. Updates Zustand store with merged favorites from Firestore
//
// On logout:
//   - Does nothing — local favorites stay in Zustand store as the fallback
//   - This is intentional: favorites are not "logged-in data"; they were local before auth.
//     Keeping them on logout avoids "where did my favorites go?" confusion.
//
// Failure mode:
//   - Any Firestore error is caught silently — local favorites remain unchanged.
//   - hasMigrated.current resets to false on next app open (ref is in-memory).
//     This means failed migration retries on the next login.
//
// IMPORTANT: Call this hook in the root layout ONLY. If called in a component that
// can unmount/remount (e.g., a tab screen), hasMigrated.current resets on remount
// and migration runs again (research pitfall 6: migration runs multiple times).

import { useEffect, useRef } from 'react';
import { useAuth } from '@/src/context/AuthContext';
import { useFavoritesStore } from '@/src/stores/favoritesStore';
import { FavoritesService } from '@/src/services/FavoritesService';

export function useFavoritesSync(): void {
  const { user } = useAuth();
  const favorites = useFavoritesStore((s) => s.favorites);
  const setFavorites = useFavoritesStore((s) => s.setFavorites);
  // Ref (not state) — prevents double-migration on re-renders; resets on app restart.
  const hasMigrated = useRef(false);

  useEffect(() => {
    if (!user) {
      // User logged out or was never logged in.
      // Local favorites stay as-is — do not clear Zustand store on logout.
      // hasMigrated.current intentionally NOT reset here — if user logs out and
      // back in during the same session, migration should not run again (it already
      // wrote the merged set to Firestore; running again would be a no-op but wasteful).
      return;
    }

    // User is logged in — sync favorites from Firestore.
    async function syncOnLogin() {
      try {
        if (!hasMigrated.current) {
          // First login this session: run migration (merge local → Firestore, dedup).
          // Migration is SILENT — no loading indicator, no confirmation (locked decision).
          hasMigrated.current = true;
          const mergedFavorites = await FavoritesService.migrateLocalToCloud(
            user!.uid,
            favorites
          );
          setFavorites(mergedFavorites);
        } else {
          // Already migrated this session (e.g., app came back from background).
          // Just load from Firestore.
          const cloudFavorites = await FavoritesService.getFavorites(user!.uid);
          setFavorites(cloudFavorites);
        }
      } catch (error) {
        // Silent failure — local favorites remain unchanged (locked decision).
        // Migration retries on next app open (hasMigrated resets at app restart).
        console.warn('[useFavoritesSync] Sync failed silently:', error);
      }
    }

    syncOnLogin();
  }, [user?.uid]); // Re-runs only when the user UID changes (login / account switch)
  // Note: favorites and setFavorites are intentionally omitted from deps array.
  // favorites is read once at login time for migration — we don't want the effect
  // to re-run every time favorites changes (that would cause sync loops).
}
```

**Part B: Update app/_layout.tsx**

Read the current `app/_layout.tsx` (modified in Plan 01 to include AuthProvider and combined isReady gate). Add `useFavoritesSync()` call inside `RootLayoutInner`.

The hook call must be inside `RootLayoutInner` (which is inside `AuthProvider`) so `useAuth()` is available. It must NOT be in `RootLayout` itself (which wraps the provider).

Add after the existing state declarations in `RootLayoutInner`:

```typescript
// Import at top of file (add to existing imports):
import { useFavoritesSync } from '@/src/hooks/useFavoritesSync';

// Inside RootLayoutInner, after existing state/hooks:
// Call favorites sync hook here — root layout never unmounts, ensuring
// hasMigrated ref persists across all navigation (research pitfall 6).
useFavoritesSync();
```

The rest of `RootLayoutInner` is unchanged. Do not modify the isReady gate, onboarding check, or Stack declaration.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

    # TypeScript check
    npx tsc --noEmit 2>&1 | head -20

    # Verify hook exports
    grep "export function useFavoritesSync" src/hooks/useFavoritesSync.ts

    # Verify hasMigrated ref (not useState)
    grep "useRef.*false\|hasMigrated" src/hooks/useFavoritesSync.ts

    # Verify effect depends on user?.uid (not user object)
    grep "user\?\.uid\|user\.uid" src/hooks/useFavoritesSync.ts

    # Verify silent failure (try/catch with console.warn)
    grep "console.warn\|catch" src/hooks/useFavoritesSync.ts

    # Verify hook is called in root layout
    grep "useFavoritesSync" app/_layout.tsx

    # Verify hook import in layout
    grep "import.*useFavoritesSync" app/_layout.tsx

    # Verify setFavorites is called with migration results
    grep "setFavorites.*mergedFavorites\|setFavorites.*cloudFavorites" src/hooks/useFavoritesSync.ts
    ```
    TypeScript clean. All greps return matches.
  </verify>
  <done>
    - `useFavoritesSync` exported from `src/hooks/useFavoritesSync.ts`
    - `hasMigrated` is a `useRef(false)` — not state (does not trigger re-renders)
    - Effect depends on `user?.uid` — runs on login/logout, not on every favorites change
    - Migration failure is caught silently with `console.warn` — local store unchanged
    - `useFavoritesSync()` called in `RootLayoutInner` in `app/_layout.tsx`
    - On login: migration runs once, then `setFavorites` called with merged/cloud data
    - On logout: no action taken, local favorites remain in store
    - TypeScript passes with no errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds

# Full TypeScript check
npx tsc --noEmit

# FavoritesService: all three methods present
grep "static async getFavorites\|static async setFavorites\|static async migrateLocalToCloud" src/services/FavoritesService.ts

# FavoritesService: map structure (not array)
grep "FavoritesMap\|merge: true" src/services/FavoritesService.ts

# useFavoritesSync: key patterns
grep "hasMigrated\|user\?\.uid\|console.warn\|migrateLocalToCloud\|setFavorites" src/hooks/useFavoritesSync.ts

# Root layout calls hook
grep "useFavoritesSync" app/_layout.tsx

# No Firestore arrayUnion in project
grep -rn "arrayUnion" src/ --include="*.ts" --include="*.tsx" && echo "WARNING: arrayUnion found — should use map" || echo "OK: no arrayUnion"
```
</verification>

<success_criteria>
- `FavoritesService` has `getFavorites`, `setFavorites`, `migrateLocalToCloud` as static methods
- Firestore favorites stored as a map (not array) — `setDoc` with `{ merge: true }` used
- `useFavoritesSync` hook uses `useRef(false)` for migration guard (not state)
- Hook effect depends only on `user?.uid` — does not loop on favorites changes
- `useFavoritesSync()` called in `RootLayoutInner` (root layout, never unmounts)
- Sync failures are caught silently — local store unchanged on Firestore error
- `npx tsc --noEmit` exits 0 across all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/05-auth-and-cloud-sync/05-02-SUMMARY.md` documenting:
- FavoritesService: data model decisions (map vs array, merge: true semantics)
- migrateLocalToCloud: which timestamp wins on conflict and why (earliest addedAt)
- useFavoritesSync: why useRef not useState for hasMigrated, why user?.uid not user in deps
- Root layout wiring: where exactly in RootLayoutInner the hook is called
- Any TypeScript issues or import path adjustments needed
- Whether any deviations from this plan were made and why
</output>
