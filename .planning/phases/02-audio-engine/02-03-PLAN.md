---
phase: 02-audio-engine
plan: "03"
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/services/TimerService.ts
  - src/stores/audioStore.ts
  - app/_layout.tsx
  - app/(tabs)/index.tsx
autonomous: false

requirements: [AUDIO-03, AUDIO-04]

must_haves:
  truths:
    - "The timer counts down correctly after the app is backgrounded and resumed — no drift from setInterval alone"
    - "When the timer reaches zero, audio fades out gently then stops — not a hard cut"
    - "Switching sounds resets the timer to its original selected duration (does not continue counting)"
    - "User can change timer duration mid-session — the new duration takes effect from that moment"
    - "Loop mode is always active — no manual toggle needed — sounds repeat seamlessly until stopped"
    - "AudioService.initialize() is called exactly once at app startup"
    - "On real iOS device: audio plays through a screen lock with the silent switch ON"
    - "On real Android device: audio plays after switching to another app"
  artifacts:
    - path: "src/services/TimerService.ts"
      provides: "AppState-aware countdown that calls AudioService.fadeOut then stop at zero"
      exports: ["TimerService"]
      min_lines: 80
    - path: "src/stores/audioStore.ts"
      provides: "Augmented Zustand store with timerStartedAt, timerDurationMs, and timer control actions"
      exports: ["useAudioStore"]
    - path: "app/_layout.tsx"
      provides: "Root layout that calls AudioService.initialize() and mounts TimerService AppState listener on startup"
  key_links:
    - from: "src/services/TimerService.ts"
      to: "src/services/AudioService.ts"
      via: "AudioService.fadeOut(durationMs) then AudioService.stop()"
      pattern: "AudioService\\.fadeOut"
    - from: "src/services/TimerService.ts"
      to: "AppState (react-native)"
      via: "AppState.addEventListener('change', ...) to recalculate elapsed on foreground"
      pattern: "AppState\\.addEventListener"
    - from: "src/stores/audioStore.ts"
      to: "src/services/TimerService.ts"
      via: "TimerService reads timerStartedAt + timerDurationMs from store"
      pattern: "timerStartedAt"
    - from: "app/_layout.tsx"
      to: "src/services/AudioService.ts"
      via: "AudioService.initialize() called in useEffect on mount"
      pattern: "AudioService\\.initialize"
---

<objective>
Wire the audio engine together: TimerService (AppState-aware countdown with fade-and-stop), an augmented audioStore (timer timestamp fields), and app/_layout.tsx initialization (AudioService.initialize + TimerService AppState listener). Ends with a human verification checkpoint confirming background audio works on real devices.

Purpose: Without AppState-aware timer correction, the countdown drifts when the app is backgrounded on iOS (JS timers pause). Without AudioService.initialize() called at startup, audio never plays in silent mode. This plan makes the engine production-ready.

Output: `src/services/TimerService.ts`, augmented `src/stores/audioStore.ts`, updated `app/_layout.tsx`, test harness `app/(tabs)/index.tsx`, verified on real devices.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-engine/02-RESEARCH.md
@.planning/phases/02-audio-engine/02-CONTEXT.md
@.planning/phases/02-audio-engine/02-01-SUMMARY.md
@.planning/phases/02-audio-engine/02-02-SUMMARY.md
@src/stores/audioStore.ts
@src/types/index.ts
@src/services/AudioService.ts
@app/_layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Augment audioStore with timer timestamp fields</name>
  <files>
    src/stores/audioStore.ts
  </files>
  <action>
Augment the existing `src/stores/audioStore.ts` (created in Phase 01-03) by adding timer timestamp fields and control actions. Do NOT rewrite the store — add to it.

**Why timestamp math instead of interval counting:**
`setInterval` pauses on iOS when the app is backgrounded. To avoid drift, the timer stores `timerStartedAt: number` (epoch ms from `Date.now()`) and `timerDurationMs: number`. On each tick AND on AppState `change → active`, TimerService recomputes remaining time as `timerDurationMs - (Date.now() - timerStartedAt)`. This pattern is correct; interval counting is not.

**Fields to add to `AudioState` interface:**
```typescript
timerStartedAt: number | null;              // Date.now() when timer started; null = timer not running
timerDurationMs: 60000 | 120000 | 180000;  // LOCKED: Timer options are 1, 2, or 3 minutes only
```

**Actions to add:**
```typescript
startTimer: (durationMs: 60000 | 120000 | 180000) => void;
// Sets timerStartedAt = Date.now(), timerDurationMs = durationMs

resetTimer: () => void;
// Sets timerStartedAt to Date.now() (resets to full duration), keeps timerDurationMs unchanged
// Used when switching sounds: reset to original duration

stopTimer: () => void;
// Sets timerStartedAt = null (timer not running)

setTimerDuration: (durationMs: 60000 | 120000 | 180000) => void;
// Updates timerDurationMs; if timer is running, also resets timerStartedAt to now
// Implements LOCKED decision: mid-session timer change allowed — new duration takes effect immediately
// NOTE: The dev-only test harness uses `setTimerDuration(10_000 as any)` to bypass this constraint
```

**Default values:**
- `timerStartedAt: null` (not running initially)
- `timerDurationMs: 60_000 as 60000` (1 minute default, matching existing `timerSeconds: 60`; use the literal cast so TypeScript satisfies the union type)

**Keep all existing fields** (`currentSoundId`, `isPlaying`, `isLooping`, `timerSeconds`, `volume`, and all existing setters + `reset`). Add the new timer timestamp fields alongside them.

**Update the `reset` action** to also clear `timerStartedAt: null` and restore `timerDurationMs: 60_000 as 60000`.

Preserve the Zustand v5 `create<T>()()` double-parens pattern from Phase 01-03.
  </action>
  <verify>
```bash
# TypeScript check
npx tsc --noEmit

# Verify new fields exist
grep "timerStartedAt" src/stores/audioStore.ts
grep "timerDurationMs" src/stores/audioStore.ts

# Verify new actions exist
grep "startTimer" src/stores/audioStore.ts
grep "resetTimer" src/stores/audioStore.ts
grep "stopTimer" src/stores/audioStore.ts
grep "setTimerDuration" src/stores/audioStore.ts

# Verify existing fields preserved
grep "currentSoundId" src/stores/audioStore.ts
grep "isPlaying" src/stores/audioStore.ts
grep "useAudioStore" src/stores/audioStore.ts
```
  </verify>
  <done>
- `src/stores/audioStore.ts` has `timerStartedAt: number | null` and `timerDurationMs: number` fields
- `startTimer`, `resetTimer`, `stopTimer`, `setTimerDuration` actions are present and correct
- All existing fields from Phase 01-03 (currentSoundId, isPlaying, isLooping, timerSeconds, volume, setters, reset) are preserved
- `npx tsc --noEmit` passes with 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 2: TimerService and app startup wiring</name>
  <files>
    src/services/TimerService.ts
    app/_layout.tsx
  </files>
  <action>
Create `src/services/TimerService.ts` and update `app/_layout.tsx` to initialize both AudioService and TimerService at startup.

---

**src/services/TimerService.ts:**

The timer service runs a 1-second interval to tick down remaining time, but always computes remaining time from `Date.now() - timerStartedAt` (not from counting intervals). When AppState transitions back to `active`, it immediately recalculates without waiting for the next tick.

LOCKED decisions implemented here:
- Timer reaching zero: audio fades out gently (AudioService.fadeOut), then hard stop
- Timer fade duration on zero: use 1500ms (Claude's Discretion — soft but quick)
- Mid-session timer change: handled in audioStore.setTimerDuration — TimerService just reads from store
- Switching sounds resets timer: caller (in Phase 3 UI) calls `audioStore.resetTimer()` — TimerService sees new timerStartedAt and keeps going

```typescript
// src/services/TimerService.ts
//
// AppState-aware timer service. Uses timestamp math (not interval counting) to prevent
// drift when the app is backgrounded on iOS (JS timers pause in background).
//
// Start a timer: call start(). Stop prematurely: call stop().
// TimerService reads/writes audioStore directly for timer state.

import { AppState, AppStateStatus } from 'react-native';
import { AudioService } from './AudioService';
import { useAudioStore } from '../stores/audioStore';

// Duration of the fade-out when timer reaches zero (Claude's Discretion)
const TIMER_FADE_MS = 1500;

class TimerServiceClass {
  private intervalId: ReturnType<typeof setInterval> | null = null;
  private appStateSubscription: ReturnType<typeof AppState.addEventListener> | null = null;
  private isFadingOut = false;

  /**
   * Start the countdown. Stores timerStartedAt in audioStore so timestamp math works
   * even if the service is recreated.
   *
   * Call this when the user selects a timer duration and taps a sound.
   */
  start(durationMs: number): void {
    this.stop(); // Clear any existing timer

    const store = useAudioStore.getState();
    store.startTimer(durationMs);

    this._startInterval();
  }

  /**
   * Stop the timer immediately (no fade). Called on manual sound toggle-off.
   */
  stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.isFadingOut = false;
    useAudioStore.getState().stopTimer();
  }

  /**
   * Initialize the AppState listener. Call once at app startup.
   * On 'active', immediately recalculates remaining time without waiting for next interval tick.
   */
  initAppStateListener(): void {
    if (this.appStateSubscription) return; // Already initialized

    this.appStateSubscription = AppState.addEventListener(
      'change',
      (nextState: AppStateStatus) => {
        if (nextState === 'active') {
          this._tick();
        }
      }
    );
  }

  /**
   * Remove AppState listener. Call on app teardown (rarely needed in Expo).
   */
  removeAppStateListener(): void {
    if (this.appStateSubscription) {
      this.appStateSubscription.remove();
      this.appStateSubscription = null;
    }
  }

  // ─── Private ──────────────────────────────────────────────────────────────

  private _startInterval(): void {
    this.intervalId = setInterval(() => {
      this._tick();
    }, 1000);
  }

  private _tick(): void {
    if (this.isFadingOut) return;

    const { timerStartedAt, timerDurationMs } = useAudioStore.getState();
    if (timerStartedAt === null) return; // Timer not running

    const elapsed = Date.now() - timerStartedAt;
    const remaining = timerDurationMs - elapsed;

    if (remaining <= 0) {
      this._onTimerExpired();
    }
    // Note: remaining time display is computed by components from timerStartedAt + timerDurationMs
    // directly — no separate "remainingMs" field needed in the store.
  }

  private async _onTimerExpired(): Promise<void> {
    if (this.isFadingOut) return;
    this.isFadingOut = true;

    // Stop the interval before the async fade to prevent re-entry
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }

    // LOCKED: timer reaching zero → audio fades out gently, then stops
    await AudioService.fadeOut(TIMER_FADE_MS);
    AudioService.stop();

    // Clear timer state in store
    useAudioStore.getState().stopTimer();
    useAudioStore.getState().setIsPlaying(false);

    this.isFadingOut = false;
  }
}

export const TimerService = new TimerServiceClass();
```

---

**app/_layout.tsx — Add AudioService.initialize() and TimerService.initAppStateListener():**

Update the existing root layout to call both services on mount. Keep all existing route structure intact — only add the initialization useEffect.

```typescript
// Add to existing app/_layout.tsx:
// 1. Import AudioService and TimerService
// 2. Add useEffect that calls both on mount

import { useEffect } from 'react';
import { Stack } from 'expo-router';
import { AudioService } from '../src/services/AudioService';
import { TimerService } from '../src/services/TimerService';

export default function RootLayout() {
  useEffect(() => {
    // Initialize audio session once at app startup.
    // This configures: playsInSilentModeIOS, staysActiveInBackground, interruptionMode.
    // Must be called before any audio playback attempt.
    AudioService.initialize().catch((err) =>
      console.error('[RootLayout] AudioService.initialize failed:', err)
    );

    // Register AppState listener for timer drift correction.
    // When app returns to foreground, timer recalculates elapsed time from stored timestamp.
    TimerService.initAppStateListener();

    return () => {
      TimerService.removeAppStateListener();
    };
  }, []);

  return (
    <Stack>
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      <Stack.Screen name="(onboarding)" options={{ headerShown: false }} />
      <Stack.Screen name="(auth)" options={{ headerShown: false }} />
      <Stack.Screen
        name="player"
        options={{
          presentation: 'modal',
          headerShown: false,
        }}
      />
    </Stack>
  );
}
```

Note: Preserve the exact existing Stack.Screen configuration from Phase 01-03. Only add the import statements and the useEffect block.
  </action>
  <verify>
```bash
# TypeScript check — full project
npx tsc --noEmit

# Verify TimerService uses timestamp math (not interval counting)
grep "Date.now()" src/services/TimerService.ts
grep "timerStartedAt" src/services/TimerService.ts

# Verify AppState listener exists
grep "AppState.addEventListener" src/services/TimerService.ts

# Verify fade on timer expiry (LOCKED behavior)
grep "AudioService.fadeOut" src/services/TimerService.ts
grep "AudioService.stop" src/services/TimerService.ts

# Verify TimerService is a module-level singleton
grep "export const TimerService = new TimerServiceClass" src/services/TimerService.ts

# Verify AudioService.initialize() called in _layout.tsx
grep "AudioService.initialize" app/_layout.tsx

# Verify TimerService.initAppStateListener() called in _layout.tsx
grep "TimerService.initAppStateListener" app/_layout.tsx

# Verify Stack.Screen for player still has presentation modal (not broken)
grep "presentation.*modal" app/_layout.tsx
```
  </verify>
  <done>
- `src/services/TimerService.ts` exports `TimerService` singleton
- Timer uses timestamp math: `timerDurationMs - (Date.now() - timerStartedAt)`
- AppState `active` event immediately re-ticks without waiting for interval
- Timer expiry: `AudioService.fadeOut(1500)` then `AudioService.stop()`
- `app/_layout.tsx` calls `AudioService.initialize()` and `TimerService.initAppStateListener()` in a useEffect on mount
- All existing Stack.Screen configuration from Phase 01-03 is preserved
- `npx tsc --noEmit` passes with 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Write test harness scaffold in app/(tabs)/index.tsx</name>
  <files>
    app/(tabs)/index.tsx
  </files>
  <action>
Replace the contents of `app/(tabs)/index.tsx` with a temporary test harness that exercises the full audio + timer stack. This screen will be replaced with the real UI in Phase 3. Its only purpose is to enable on-device verification of AUDIO-01 through AUDIO-04.

```typescript
// app/(tabs)/index.tsx
// TEMPORARY TEST HARNESS — replace with real UI in Phase 3.
// Exercises: sound play/stop, crossfade, background audio, loop, timer with fade-out.

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { SOUNDS } from '../../src/config/sounds';
import { SoundCacheService } from '../../src/services/SoundCacheService';
import { AudioService } from '../../src/services/AudioService';
import { TimerService } from '../../src/services/TimerService';
import { useAudioStore } from '../../src/stores/audioStore';

export default function TestHarnessScreen() {
  const { isPlaying, timerDurationMs } = useAudioStore();

  // Play the first sound and start the timer (60-second countdown)
  const handlePlay = async () => {
    const sound = SOUNDS[0];
    const uri = await SoundCacheService.getLocalUri(sound);
    if (!uri) return;
    await AudioService.play(sound.id, uri);
    useAudioStore.getState().setIsPlaying(true);
    useAudioStore.getState().setCurrentSoundId(sound.id);
    TimerService.start(60_000);  // 60-second timer to verify AUDIO-04
  };

  // Play the second sound while first is playing — verifies crossfade (AUDIO-01)
  const handleCrossfade = async () => {
    const sound = SOUNDS[1] ?? SOUNDS[0];
    const uri = await SoundCacheService.getLocalUri(sound);
    if (!uri) return;
    await AudioService.play(sound.id, uri);
    useAudioStore.getState().setIsPlaying(true);
    useAudioStore.getState().setCurrentSoundId(sound.id);
    TimerService.start(60_000);
  };

  // Stop the timer immediately without audio fade (manual stop)
  const handleStopTimer = () => {
    TimerService.stop();
  };

  // Test AUDIO-04 with a 10-second countdown — uses cast because 10_000 is
  // not a valid production timer value (LOCKED: 1, 2, or 3 minutes only)
  const handleShortTimer = async () => {
    const sound = SOUNDS[0];
    const uri = await SoundCacheService.getLocalUri(sound);
    if (!uri) return;
    await AudioService.play(sound.id, uri);
    useAudioStore.getState().setIsPlaying(true);
    useAudioStore.getState().setCurrentSoundId(sound.id);
    useAudioStore.getState().setTimerDuration(10_000 as any);
    TimerService.start(10_000 as any);
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Audio Engine Test Harness</Text>
      <Text style={styles.subtitle}>Phase 2 — replace with real UI in Phase 3</Text>

      <TouchableOpacity style={styles.button} onPress={handlePlay}>
        <Text style={styles.buttonText}>Play Sound 1 + Start 60s Timer</Text>
      </TouchableOpacity>

      <TouchableOpacity style={styles.button} onPress={handleCrossfade}>
        <Text style={styles.buttonText}>Crossfade to Sound 2 (700ms)</Text>
      </TouchableOpacity>

      <TouchableOpacity style={[styles.button, styles.warningButton]} onPress={handleShortTimer}>
        <Text style={styles.buttonText}>Play + 10s Timer (AUDIO-04 test)</Text>
      </TouchableOpacity>

      <TouchableOpacity style={[styles.button, styles.stopButton]} onPress={handleStopTimer}>
        <Text style={styles.buttonText}>Stop Timer (no fade)</Text>
      </TouchableOpacity>

      <Text style={styles.status}>
        Playing: {isPlaying ? 'YES' : 'NO'} | Timer duration: {timerDurationMs}ms
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, alignItems: 'center', justifyContent: 'center', gap: 16, padding: 24 },
  title: { fontSize: 20, fontWeight: 'bold' },
  subtitle: { fontSize: 13, color: '#888', marginBottom: 8 },
  button: { backgroundColor: '#4A90E2', padding: 14, borderRadius: 8, width: '100%', alignItems: 'center' },
  warningButton: { backgroundColor: '#E2A84A' },
  stopButton: { backgroundColor: '#E24A4A' },
  buttonText: { color: '#fff', fontWeight: '600' },
  status: { marginTop: 16, fontSize: 13, color: '#555' },
});
```

**Key wiring this scaffold verifies:**
- `SoundCacheService.getLocalUri` then `AudioService.play` then `TimerService.start(60_000)` proves AUDIO-01 and AUDIO-04 are connected end-to-end
- `handleShortTimer` uses `TimerService.start(10_000 as any)` (dev-only bypass of the production `60000 | 120000 | 180000` union) to run a fast countdown on device
- `handleStopTimer` calls `TimerService.stop()` to verify the manual stop path
  </action>
  <verify>
```bash
# TypeScript check — full project (10_000 as any bypass must not cause errors)
npx tsc --noEmit

# Verify TimerService.start() is called after AudioService.play() in the harness
grep "TimerService.start" "app/(tabs)/index.tsx"

# Verify the short-timer bypass uses cast correctly
grep "as any" "app/(tabs)/index.tsx"

# Verify TimerService.stop() control exists
grep "TimerService.stop" "app/(tabs)/index.tsx"

# Verify the harness imports the correct services
grep "SoundCacheService\|AudioService\|TimerService" "app/(tabs)/index.tsx"
```
  </verify>
  <done>
- `app/(tabs)/index.tsx` is a working test harness with four buttons: play+60s timer, crossfade, play+10s timer, stop timer
- `TimerService.start(60_000)` is called immediately after `AudioService.play()` in both play handlers
- `TimerService.start(10_000 as any)` and `setTimerDuration(10_000 as any)` are present for the short-timer AUDIO-04 test
- `TimerService.stop()` button is present for manual stop verification
- `npx tsc --noEmit` passes with 0 errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify audio engine on real devices (background audio, loop, timer)</name>
  <files></files>
  <action>
Human verification of all automated work from Tasks 1–3 on real iOS and Android hardware. Claude-automated scaffold and services are complete; this checkpoint confirms correct device behavior.

What was built:
- Test harness in app/(tabs)/index.tsx (Task 3) with four controls: play sound + 60s timer, crossfade, play + 10s timer (AUDIO-04 fast test), stop timer
- TimerService, AudioService, SoundCacheService wired together end-to-end
- AudioService.initialize() and TimerService.initAppStateListener() called at app startup via app/_layout.tsx

Build and install EAS Development Build on real devices:

```bash
eas build --platform all --profile development --non-interactive
```
  </action>
  <verify>
**Step 1 — Auto-play (AUDIO-01):**
1. Open app on device, tap "Play Sound 1 + Start 60s Timer"
2. Expected: Audio starts within 1-2 seconds (download on first play, instant on repeat)
3. Tap "Stop Timer (no fade)": Expected: Timer stops; audio is unaffected
4. Tap "Crossfade to Sound 2": Expected: Smooth crossfade over ~0.7 seconds

**Step 2 — Background audio on iOS (AUDIO-02):**
1. Tap "Play Sound 1 + Start 60s Timer"
2. Press Home button, then lock screen (silent switch ON)
3. Wait 10 seconds
4. Expected: Audio continues playing through the lock screen

**Step 3 — Background audio on Android (AUDIO-02):**
1. Tap "Play Sound 1 + Start 60s Timer"
2. Switch to another app (e.g., Chrome)
3. Wait 10 seconds
4. Expected: Audio continues in background

**Step 4 — Loop (AUDIO-03):**
Play sound past its ~30s clip end.
Expected: Loops seamlessly. Note any audible gap — if gap exists on iOS, CAF format conversion is needed.

**Step 5 — Timer stops audio with fade (AUDIO-04):**
1. Tap "Play + 10s Timer (AUDIO-04 test)"
2. Stay in the foreground — wait ~10 seconds
3. Expected: Audio fades out gently (~1.5s) then stops completely
4. Tap "Play + 10s Timer" again, then immediately background the app
5. Return after ~12 seconds
6. Expected: Audio has stopped (timer fired correctly during background — AppState correction working)

**Step 6 — Document findings:**
- iOS gapless loop: gap or no gap?
- Firebase Storage download: succeeds without auth or 403?
- setAudioModeAsync mid-crossfade: any audio interruption?
  </verify>
  <done>
- Auto-play starts audio in under 2 seconds on both platforms
- Audio plays through screen lock on iOS (silent switch ON)
- Audio plays after app switch on Android
- Sound loops continuously past clip boundary
- Timer stops audio after countdown with gentle fade (~1.5s)
- Timer fires correctly after backgrounding (AppState correction confirmed, no drift)
  </done>
  <resume-signal>Type "approved" or describe issues found during testing</resume-signal>
</task>

</tasks>

<verification>
After automated tasks complete (before checkpoint Task 4):

```bash
# Full project TypeScript
npx tsc --noEmit
# Expected: 0 errors

# Timer uses timestamp math
grep "Date.now()" src/services/TimerService.ts

# AppState listener registered
grep "AppState.addEventListener" src/services/TimerService.ts

# AudioService fade-then-stop on timer expiry
grep "AudioService.fadeOut" src/services/TimerService.ts

# audioStore has all new fields
grep "timerStartedAt" src/stores/audioStore.ts
grep "timerDurationMs" src/stores/audioStore.ts
grep "startTimer\|resetTimer\|stopTimer\|setTimerDuration" src/stores/audioStore.ts | wc -l
# Expected: 4

# app/_layout.tsx has both initializations
grep "AudioService.initialize\|TimerService.initAppStateListener" app/_layout.tsx | wc -l
# Expected: 2

# Test harness: TimerService.start() is called after AudioService.play()
grep "TimerService.start" "app/(tabs)/index.tsx"

# Test harness: short-timer dev bypass uses cast
grep "as any" "app/(tabs)/index.tsx"

# Test harness: TimerService.stop() control present
grep "TimerService.stop" "app/(tabs)/index.tsx"

# Lint passes
npx eslint . --ext .ts,.tsx --max-warnings=0
```
</verification>

<success_criteria>
- `src/services/TimerService.ts` uses timestamp math (`Date.now() - timerStartedAt`) for drift-free countdown
- AppState `active` event triggers an immediate tick (no wait for next interval)
- Timer expiry: `AudioService.fadeOut(1500)` followed by `AudioService.stop()`
- `src/stores/audioStore.ts` has `timerStartedAt: number | null` and `timerDurationMs: 60000 | 120000 | 180000` (union enforces LOCKED timer options); `startTimer`, `resetTimer`, `stopTimer`, `setTimerDuration` actions present; all existing fields preserved
- `app/_layout.tsx` calls `AudioService.initialize()` and `TimerService.initAppStateListener()` on mount
- `app/(tabs)/index.tsx` test harness has four buttons: `TimerService.start(60_000)` called after `AudioService.play()`, crossfade, 10s timer via `(10_000 as any)` cast, and `TimerService.stop()`
- Human checkpoint (Task 4) verified: auto-play works, background audio works on iOS and Android, loop plays continuously, timer stops audio after countdown with gentle fade
- `npx tsc --noEmit` and `npx eslint . --ext .ts,.tsx --max-warnings=0` pass
</success_criteria>

<output>
After checkpoint approval, create `.planning/phases/02-audio-engine/02-03-SUMMARY.md` following the summary template.
</output>
