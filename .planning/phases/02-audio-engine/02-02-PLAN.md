---
phase: 02-audio-engine
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/sounds.ts
  - src/services/SoundCacheService.ts
autonomous: true
requirements: [AUDIO-01]

must_haves:
  truths:
    - "A static catalog of at least 6 sounds (2 per category) is defined in TypeScript and importable anywhere"
    - "SoundCacheService.getLocalUri(sound) returns a file:// URI immediately for a previously cached sound — no network call"
    - "SoundCacheService.getLocalUri(sound) downloads from Firebase Storage on first call and stores in documentDirectory (not cacheDirectory)"
    - "Cached files survive app restarts — they are permanent until reinstall"
    - "A loading state is provided during first-play download so the caller can show UI feedback"
  artifacts:
    - path: "src/config/sounds.ts"
      provides: "Static sound catalog mapping sound IDs to Firebase Storage paths and metadata"
      exports: ["SOUNDS", "SOUNDS_BY_CATEGORY", "SoundConfig"]
      min_lines: 40
    - path: "src/services/SoundCacheService.ts"
      provides: "Firebase Storage URL resolution + local caching via expo-file-system"
      exports: ["SoundCacheService"]
      min_lines: 60
  key_links:
    - from: "src/services/SoundCacheService.ts"
      to: "@react-native-firebase/storage"
      via: "storage().ref(sound.storageRef).getDownloadURL()"
      pattern: "getDownloadURL"
    - from: "src/services/SoundCacheService.ts"
      to: "expo-file-system/legacy"
      via: "FileSystem.documentDirectory + downloadAsync"
      pattern: "documentDirectory"
    - from: "src/config/sounds.ts"
      to: "src/types/index.ts"
      via: "SoundConfig extends Sound shape"
      pattern: "SoundCategory"
---

<objective>
Define the static sound catalog and build the SoundCacheService that resolves Firebase Storage paths to local cached URIs. AudioService (Plan 02-01) receives a `file://` URI to play — this plan produces that URI. The cache is permanent in `documentDirectory` (not `cacheDirectory`) so sounds never expire after being cached.

Purpose: AudioService is a pure playback engine — it knows nothing about Firebase or caching. This plan is the data layer that feeds it. Separating catalog + cache from playback keeps both services testable and replaceable.

Output: `src/config/sounds.ts` (static catalog) + `src/services/SoundCacheService.ts` (URL resolution + cache).
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-engine/02-RESEARCH.md
@.planning/phases/02-audio-engine/02-CONTEXT.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Static sound catalog (src/config/sounds.ts)</name>
  <files>
    src/config/sounds.ts
  </files>
  <action>
Create `src/config/sounds.ts`. This is a pure TypeScript module — no network calls, no React. It maps sound IDs to Firebase Storage paths plus display metadata.

**Rules:**
- `storageRef` is the Firebase Storage path (e.g., `sounds/rain-01.mp3`) — NOT a full URL. SoundCacheService resolves URLs at runtime.
- Include at least 6 sounds covering at least 3 categories (rain, fire, forest are the highest-priority categories based on PROJECT.md). Placeholder sounds are fine — the actual audio files are uploaded separately to Firebase Storage.
- `isPremium: false` for all sounds in Phase 2 — premium gating is Phase 6.
- `durationSeconds` uses the `TimerDuration` type (60 | 120 | 180). Set all to 60 for Phase 2 — these are ~30s loop clips whose session length is timer-controlled, not file-length controlled. The value represents the default session timer, not the audio file length.

```typescript
// src/config/sounds.ts
// Static sound catalog. storageRef is the Firebase Storage path — not a download URL.
// URLs are resolved at runtime by SoundCacheService.
// All sounds are free-tier in Phase 2. Premium gating is Phase 6.

import type { SoundCategory, TimerDuration } from '../types';

export interface SoundConfig {
  id: string;
  title: string;
  category: SoundCategory;
  storageRef: string;    // Firebase Storage path: "sounds/rain-01.mp3"
  isPremium: boolean;
  defaultTimerSeconds: TimerDuration;
  thumbnailUrl: string | null; // Phase 3 will set real values
}

export const SOUNDS: SoundConfig[] = [
  {
    id: 'rain-01',
    title: 'Gentle Rain',
    category: 'rain',
    storageRef: 'sounds/rain-01.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
  {
    id: 'rain-02',
    title: 'Heavy Rain',
    category: 'rain',
    storageRef: 'sounds/rain-02.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
  {
    id: 'fire-01',
    title: 'Crackling Fire',
    category: 'fire',
    storageRef: 'sounds/fire-01.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
  {
    id: 'fire-02',
    title: 'Campfire',
    category: 'fire',
    storageRef: 'sounds/fire-02.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
  {
    id: 'forest-01',
    title: 'Forest Birds',
    category: 'forest',
    storageRef: 'sounds/forest-01.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
  {
    id: 'forest-02',
    title: 'Deep Forest',
    category: 'forest',
    storageRef: 'sounds/forest-02.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
  {
    id: 'ocean-01',
    title: 'Ocean Waves',
    category: 'ocean',
    storageRef: 'sounds/ocean-01.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
  {
    id: 'wind-01',
    title: 'Gentle Wind',
    category: 'wind',
    storageRef: 'sounds/wind-01.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
  {
    id: 'white-noise-01',
    title: 'White Noise',
    category: 'white-noise',
    storageRef: 'sounds/white-noise-01.mp3',
    isPremium: false,
    defaultTimerSeconds: 60,
    thumbnailUrl: null,
  },
];

/** Lookup by ID — O(1) */
export const SOUNDS_BY_ID: Record<string, SoundConfig> = Object.fromEntries(
  SOUNDS.map((s) => [s.id, s])
);

/** Group by category for library screen rendering */
export const SOUNDS_BY_CATEGORY: Record<SoundCategory, SoundConfig[]> = {
  rain: SOUNDS.filter((s) => s.category === 'rain'),
  fire: SOUNDS.filter((s) => s.category === 'fire'),
  forest: SOUNDS.filter((s) => s.category === 'forest'),
  ocean: SOUNDS.filter((s) => s.category === 'ocean'),
  wind: SOUNDS.filter((s) => s.category === 'wind'),
  'white-noise': SOUNDS.filter((s) => s.category === 'white-noise'),
};
```
  </action>
  <verify>
```bash
# TypeScript check
npx tsc --noEmit

# Verify file exists and has SoundConfig interface
grep "export interface SoundConfig" src/config/sounds.ts

# Verify at least 6 entries in SOUNDS array
grep -c "id:" src/config/sounds.ts
# Expected: 9 (or >= 6)

# Verify no full URLs — only Storage paths
grep "https://" src/config/sounds.ts && echo "ERROR: full URLs found" || echo "OK: no full URLs"

# Verify SOUNDS_BY_ID and SOUNDS_BY_CATEGORY exported
grep "export const SOUNDS_BY_ID" src/config/sounds.ts
grep "export const SOUNDS_BY_CATEGORY" src/config/sounds.ts
```
  </verify>
  <done>
- `src/config/sounds.ts` exports `SoundConfig` interface, `SOUNDS` array (9 entries), `SOUNDS_BY_ID` and `SOUNDS_BY_CATEGORY`
- All storageRef values are Firebase Storage paths (not full URLs)
- All sounds have `isPremium: false`
- `npx tsc --noEmit` passes with 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 2: SoundCacheService — Firebase URL resolution + permanent local cache</name>
  <files>
    src/services/SoundCacheService.ts
  </files>
  <action>
Create `src/services/SoundCacheService.ts`. This service checks whether a sound is cached locally first; if not, downloads it from Firebase Storage and saves it to `documentDirectory` (permanent storage, not cacheDirectory which can be cleared by the OS).

**Critical rules from research:**
- Use `FileSystem.documentDirectory` — NEVER `cacheDirectory`. cacheDirectory can be purged by the OS; documentDirectory is permanent until reinstall. This is a LOCKED requirement ("permanent cache until reinstall").
- Import expo-file-system using `'expo-file-system/legacy'` for the documented `downloadAsync` API. The new `expo-file-system` v2 API has different method names; use the legacy import to match the researched pattern.
- Firebase Storage Security Rules must allow unauthenticated reads for the `sounds/` path. Flag this in a comment — the user must verify this in the Firebase Console.
- On download failure: return `null` and let the caller handle it (Claude's Discretion: brief toast, handled in Plan 02-03 UI integration).
- The in-progress download map prevents duplicate concurrent downloads for the same sound ID.

```typescript
// src/services/SoundCacheService.ts
//
// Resolves Firebase Storage paths → local file:// URIs.
// Cache is PERMANENT in documentDirectory (survives app restarts, cleared only on reinstall).
//
// IMPORTANT: Firebase Storage Security Rules must allow unauthenticated reads
// for the "sounds/" prefix. Verify this in Firebase Console → Storage → Rules.
// Example rule: allow read: if request.auth == null || request.auth != null;

import * as FileSystem from 'expo-file-system/legacy';
import storage from '@react-native-firebase/storage';
import type { SoundConfig } from '../config/sounds';

class SoundCacheServiceClass {
  // Tracks in-progress downloads to prevent duplicate concurrent fetches
  private inProgress: Map<string, Promise<string | null>> = new Map();

  /**
   * Returns the local file:// URI for a sound.
   *
   * Flow:
   * 1. Check documentDirectory for existing cached file → return immediately (instant)
   * 2. If downloading already in progress for this ID → await same promise (dedup)
   * 3. Otherwise: resolve Firebase Storage download URL → download → cache → return URI
   *
   * Returns null on failure (no internet, Firebase unreachable, Storage rule denied).
   * The caller is responsible for showing error feedback.
   */
  async getLocalUri(sound: SoundConfig): Promise<string | null> {
    const localPath = this._localPath(sound.id);

    // Cache hit — return immediately
    const fileInfo = await FileSystem.getInfoAsync(localPath);
    if (fileInfo.exists) {
      return localPath;
    }

    // Dedup: if already downloading, return the same promise
    if (this.inProgress.has(sound.id)) {
      return this.inProgress.get(sound.id)!;
    }

    // Start download
    const downloadPromise = this._download(sound, localPath);
    this.inProgress.set(sound.id, downloadPromise);

    try {
      return await downloadPromise;
    } finally {
      this.inProgress.delete(sound.id);
    }
  }

  /**
   * Checks whether a sound is already cached locally without triggering a download.
   * Useful for showing a "cached" indicator in the UI.
   */
  async isCached(soundId: string): Promise<boolean> {
    const fileInfo = await FileSystem.getInfoAsync(this._localPath(soundId));
    return fileInfo.exists;
  }

  /**
   * Returns the expected local path for a sound ID.
   * Path: {documentDirectory}sounds/{soundId}.mp3
   */
  private _localPath(soundId: string): string {
    // documentDirectory always ends with '/'. Append our subdirectory.
    return `${FileSystem.documentDirectory}sounds/${soundId}.mp3`;
  }

  private async _download(sound: SoundConfig, localPath: string): Promise<string | null> {
    try {
      // Ensure the sounds/ subdirectory exists
      const dirPath = `${FileSystem.documentDirectory}sounds/`;
      const dirInfo = await FileSystem.getInfoAsync(dirPath);
      if (!dirInfo.exists) {
        await FileSystem.makeDirectoryAsync(dirPath, { intermediates: true });
      }

      // Resolve Firebase Storage download URL
      const downloadUrl = await storage().ref(sound.storageRef).getDownloadURL();

      // Download to permanent location
      const result = await FileSystem.downloadAsync(downloadUrl, localPath);

      if (result.status !== 200) {
        console.warn(`[SoundCacheService] Download failed for ${sound.id}: HTTP ${result.status}`);
        return null;
      }

      return localPath;
    } catch (error) {
      console.warn(`[SoundCacheService] Failed to cache ${sound.id}:`, error);
      // Clean up partial file if download failed midway
      try {
        const partial = await FileSystem.getInfoAsync(localPath);
        if (partial.exists) {
          await FileSystem.deleteAsync(localPath, { idempotent: true });
        }
      } catch {
        // Ignore cleanup errors
      }
      return null;
    }
  }
}

export const SoundCacheService = new SoundCacheServiceClass();
```
  </action>
  <verify>
```bash
# TypeScript check
npx tsc --noEmit

# Verify documentDirectory usage (NOT cacheDirectory)
grep "documentDirectory" src/services/SoundCacheService.ts
grep "cacheDirectory" src/services/SoundCacheService.ts && echo "ERROR: use documentDirectory" || echo "OK"

# Verify legacy import for downloadAsync
grep "expo-file-system/legacy" src/services/SoundCacheService.ts

# Verify firebase storage ref usage
grep "getDownloadURL" src/services/SoundCacheService.ts

# Verify dedup map
grep "inProgress" src/services/SoundCacheService.ts

# Verify module-level singleton export
grep "export const SoundCacheService = new SoundCacheServiceClass" src/services/SoundCacheService.ts

# Verify partial-file cleanup on download error
grep "deleteAsync" src/services/SoundCacheService.ts
```
  </verify>
  <done>
- `src/services/SoundCacheService.ts` exports `SoundCacheService` as a module-level singleton
- `getLocalUri(sound)` checks documentDirectory first, returns immediately on cache hit
- Download uses `expo-file-system/legacy` with `downloadAsync` to documentDirectory
- Firebase Storage URL resolved via `storage().ref(sound.storageRef).getDownloadURL()`
- Concurrent downloads for same ID are deduplicated via `inProgress` Map
- Returns `null` on failure; partial files are cleaned up
- `npx tsc --noEmit` passes with 0 errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
# TypeScript across the whole project
npx tsc --noEmit
# Expected: 0 errors

# Catalog integrity
node -e "const s = require('./src/config/sounds.ts'); console.log(s.SOUNDS.length)"
# Or check via grep:
grep -c "storageRef:" src/config/sounds.ts
# Expected: >= 6

# No full URLs in catalog
grep "https://" src/config/sounds.ts && echo "FAIL" || echo "PASS: no raw URLs"

# Permanent cache (documentDirectory, not cacheDirectory)
grep "documentDirectory" src/services/SoundCacheService.ts
grep "cacheDirectory" src/services/SoundCacheService.ts && echo "FAIL" || echo "PASS"

# Legacy FileSystem import
grep "expo-file-system/legacy" src/services/SoundCacheService.ts

# Both singletons exported
grep "export const SoundCacheService" src/services/SoundCacheService.ts
grep "export const SOUNDS" src/config/sounds.ts
```
</verification>

<success_criteria>
- `src/config/sounds.ts` has 9 sounds across 5 categories, all with `isPremium: false` and Firebase Storage paths (not URLs)
- `SOUNDS_BY_ID` and `SOUNDS_BY_CATEGORY` are exported for O(1) lookup and library rendering
- `src/services/SoundCacheService.ts` uses `documentDirectory` exclusively (permanent cache)
- First-play triggers a Firebase Storage download; subsequent plays return cached URI instantly
- Concurrent downloads for the same sound are deduplicated
- Download failures return `null` and clean up partial files
- `npx tsc --noEmit` passes across both new files and the full project
</success_criteria>

<output>
After completion, create `.planning/phases/02-audio-engine/02-02-SUMMARY.md` following the summary template.
</output>
