---
phase: 04-favorites
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - src/components/FavoriteButton.tsx
  - src/components/SoundCard.tsx
  - app/player.tsx
autonomous: true
requirements:
  - FAV-01
  - SET-02

must_haves:
  truths:
    - "A heart icon appears on every SoundCard in the library — filled rose when favorited, outlined grey when not"
    - "A heart icon appears on the player screen — same visual states as on the card"
    - "Tapping the heart toggles favorite status immediately with a gentle scale pop animation (no confirmation)"
    - "The heart icon reflects the correct state on every re-render without subscribing to the full store"
    - "When the player screen opens (or gains focus), the timer pre-fills from uiStore.defaultTimerDuration if no sound is currently playing"
    - "Changing the timer in the player also updates uiStore.defaultTimerDuration (locked decision: no session vs default separation)"
  artifacts:
    - path: "src/components/FavoriteButton.tsx"
      provides: "Pressable heart icon with withSequence/withSpring animation; reads isFavorite, calls toggleFavorite via scoped selectors"
      exports: ["FavoriteButton"]
      min_lines: 50
    - path: "src/components/SoundCard.tsx"
      provides: "SoundCard with FavoriteButton added in top-right corner (alongside existing PRO badge)"
      min_lines: 60
    - path: "app/player.tsx"
      provides: "Player screen with FavoriteButton in BottomControlPill; useFocusEffect timer pre-fill; timer changes write to both audioStore and uiStore"
  key_links:
    - from: "src/components/FavoriteButton.tsx"
      to: "src/stores/favoritesStore.ts"
      via: "useFavoritesStore scoped selector for isFavorite(soundId) and toggleFavorite"
      pattern: "useFavoritesStore.*isFavorite|useFavoritesStore.*toggleFavorite"
    - from: "src/components/SoundCard.tsx"
      to: "src/components/FavoriteButton.tsx"
      via: "FavoriteButton soundId={sound.id} rendered in card"
      pattern: "FavoriteButton"
    - from: "app/player.tsx"
      to: "src/stores/uiStore.ts"
      via: "useFocusEffect reads defaultTimerDuration on screen focus; timer change calls setDefaultTimerDuration"
      pattern: "defaultTimerDuration"
---

<objective>
Build the FavoriteButton component with spring animation, add it to SoundCard and the player screen, and wire the timer pre-fill coupling so changing the timer anywhere persists as the default.

Purpose: This plan delivers FAV-01 (the heart toggle UI) and completes the SET-02 coupling (timer changes persist). Plans 04-01 built the data layer; this plan wires up the interactive UI.
Output: FavoriteButton component, updated SoundCard, updated player screen with heart and timer coupling.
</objective>

<execution_context>
@/Users/manuelfrancogiraldez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/manuelfrancogiraldez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-favorites/04-RESEARCH.md
@.planning/phases/04-favorites/04-01-SUMMARY.md
@src/components/SoundCard.tsx
@app/player.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FavoriteButton component with spring animation</name>
  <files>
    src/components/FavoriteButton.tsx
  </files>
  <action>
Create `src/components/FavoriteButton.tsx`. This is a small reusable component used in both SoundCard and the player screen.

Design decisions (Claude's Discretion from context, confirmed by research):
- Heart animation: `withSequence(withSpring(1.3, ...), withSpring(1.0, ...))` — gentle pop, calm aesthetic
- Unfavorite: immediate removal, no undo toast
- Inactive color: `#94a3b8` (slate-400), active color: `#f43f5e` (rose-500)

Icon system: Phase 3 uses `@expo/vector-icons` with `MaterialIcons` (confirmed from 03-01-PLAN and 03-03-PLAN which use `MaterialIcons name="music-note"`, `MaterialIcons name="chevron-right"`). Use `MaterialIcons` with `name="favorite"` (filled) and `name="favorite-border"` (outlined).

CRITICAL: Use narrowly scoped Zustand selectors to prevent all SoundCards re-rendering when any favorite changes:
- `useFavoritesStore((s) => s.isFavorite(soundId))` — only re-renders this button when THIS sound's status changes
- Call `useFavoritesStore.getState().toggleFavorite` directly for the action (no subscription to the function reference)

```typescript
// src/components/FavoriteButton.tsx
//
// Heart toggle with gentle pop animation.
// Uses scoped Zustand selectors to avoid re-rendering unrelated SoundCards.
// Icon system: @expo/vector-icons MaterialIcons (established in Phase 3).
import { Pressable } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSequence,
  withSpring,
} from 'react-native-reanimated';
import { MaterialIcons } from '@expo/vector-icons';
import { useFavoritesStore } from '@/src/stores/favoritesStore';

interface FavoriteButtonProps {
  soundId: string;
  size?: number;    // icon size in px, defaults to 22
  style?: object;   // optional container style
}

export function FavoriteButton({ soundId, size = 22, style }: FavoriteButtonProps) {
  // Scoped selector: only re-renders when THIS sound's favorite status changes
  const isFavorite = useFavoritesStore((s) => s.isFavorite(soundId));
  const scale = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  const handlePress = () => {
    // Call getState() directly — no subscription to the function reference
    useFavoritesStore.getState().toggleFavorite(soundId);
    // Calm pop: scale up slightly, then spring back to 1
    scale.value = withSequence(
      withSpring(1.3, { stiffness: 200, damping: 10, mass: 1 }),
      withSpring(1.0, { stiffness: 150, damping: 14, mass: 1 }),
    );
  };

  return (
    <Pressable onPress={handlePress} hitSlop={8} style={style}>
      <Animated.View style={animatedStyle}>
        <MaterialIcons
          name={isFavorite ? 'favorite' : 'favorite-border'}
          size={size}
          color={isFavorite ? '#f43f5e' : '#94a3b8'}
        />
      </Animated.View>
    </Pressable>
  );
}
```
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds
    # TypeScript check
    npx tsc --noEmit 2>&1 | grep "FavoriteButton" | head -10

    # Verify scoped selector (not full store subscription)
    grep "isFavorite(soundId)" src/components/FavoriteButton.tsx

    # Verify getState() pattern for toggle action
    grep "getState().toggleFavorite" src/components/FavoriteButton.tsx

    # Verify animation uses withSequence + withSpring
    grep "withSequence\|withSpring" src/components/FavoriteButton.tsx

    # Verify MaterialIcons used (not Ionicons or custom font)
    grep "MaterialIcons" src/components/FavoriteButton.tsx
    ```
    TypeScript must pass for this file. All greps must return results.
  </verify>
  <done>
    - `FavoriteButton` component exported from `src/components/FavoriteButton.tsx`
    - Uses `MaterialIcons` `favorite` / `favorite-border` icons (rose-500 / slate-400)
    - Scoped Zustand selector `(s) => s.isFavorite(soundId)` — no broad store subscription
    - `useFavoritesStore.getState().toggleFavorite` called directly (no function reference subscription)
    - Animation: `withSequence(withSpring(1.3), withSpring(1.0))` — gentle scale pop
    - `hitSlop={8}` for easier tap target
    - No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add FavoriteButton to SoundCard and wire timer coupling in player</name>
  <files>
    src/components/SoundCard.tsx
    app/player.tsx
  </files>
  <action>
**Part A: Update SoundCard to include FavoriteButton**

Read `src/components/SoundCard.tsx` (built in Phase 3), then add the `FavoriteButton` component to it.

The heart appears at the top-right of the card, alongside (or near) the existing PRO badge. Since the PRO badge is also top-right, position the FavoriteButton at the bottom-right so they don't overlap:

```typescript
// Add import at top:
import { FavoriteButton } from './FavoriteButton';

// In the component JSX, add FavoriteButton positioned at bottom-right corner:
// (inside the card view, as an absolute-positioned sibling to the gradient and text)
<FavoriteButton
  soundId={sound.id}
  size={20}
  style={{
    position: 'absolute',
    bottom: 10,
    right: 10,
    // FavoriteButton sits alongside the duration text row — adjust if needed
    // to avoid overlapping the sound name / subtitle text area
  }}
/>
```

Note: If the card's bottom text area (name, subtitle, duration) occupies the full bottom strip and the FavoriteButton would overlap it, position it instead in the bottom-right corner of the card with a semi-transparent backing circle:

```typescript
<View style={{
  position: 'absolute',
  bottom: 8,
  right: 8,
  backgroundColor: 'rgba(0,0,0,0.35)',
  borderRadius: 12,
  padding: 4,
}}>
  <FavoriteButton soundId={sound.id} size={18} />
</View>
```

Inspect the Phase 3 SoundCard structure carefully and place the button where it does not overlap the name/subtitle text. The backing circle approach is safer and matches the mock's card-level heart placement.

**Part B: Update player screen with FavoriteButton and timer coupling**

Read `app/player.tsx` (built in Phase 3), then apply two changes:

**Change 1 — FavoriteButton in player:**
Add `FavoriteButton` to the player's `BottomControlPill` (the bottom row of controls built in Phase 3). The heart takes the position that was a placeholder for favorites in the pill. Import `FavoriteButton` and pass `soundId` from the current sound's ID (read from `audioStore.currentSoundId` or from the route params `soundId` that Phase 3 passes via `router.push({ pathname: '/player', params: { soundId } })`).

```typescript
// Add import:
import { FavoriteButton } from '@/src/components/FavoriteButton';

// In the BottomControlPill or controls row, replace the placeholder heart icon with:
<FavoriteButton soundId={currentSoundId} size={24} />
// where currentSoundId is the current sound from audioStore or route params
```

**Change 2 — Timer pre-fill and coupling:**
The locked decision states: "changing the timer in any screen updates the saved default." Implement this in two steps:

Step 2a — Pre-fill on focus: When the player screen gains focus (use `useFocusEffect` from `expo-router`), read `uiStore.defaultTimerDuration` and write it to `audioStore` if no sound is currently playing. This ensures each new session starts with the user's saved default.

Step 2b — Coupling on timer change: Wherever the player's timer segmented control writes to `audioStore` (the timer duration change handler from Phase 2), also call `useUIStore.getState().setDefaultTimerDuration(newDuration)`. This persists every timer change as the new default.

```typescript
// Add imports:
import { useFocusEffect } from 'expo-router';
import { useCallback } from 'react';
import { useUIStore } from '@/src/stores/uiStore';
import { useAudioStore } from '@/src/stores/audioStore'; // already imported in Phase 3

// Add useFocusEffect hook to the player screen component:
useFocusEffect(
  useCallback(() => {
    const { defaultTimerDuration } = useUIStore.getState();
    const { isPlaying } = useAudioStore.getState();
    // Only pre-fill if not mid-session (no sound actively playing)
    if (!isPlaying) {
      // Write to audioStore timer. Use the setter that Phase 1/2 established.
      // Phase 1 scaffold used setTimer(seconds). Phase 2's 02-03 plan may have
      // changed this to timerDurationMs / setTimerDuration — read the current
      // audioStore to find the correct setter name before writing this.
      // If setTimer(seconds) exists: useAudioStore.getState().setTimer(defaultTimerDuration)
      // If setTimerDuration(ms) exists: useAudioStore.getState().setTimerDuration(defaultTimerDuration * 1000)
      // Use whichever matches the actual audioStore implementation.
      useAudioStore.getState().setTimer(defaultTimerDuration); // adjust if Phase 2 changed setter name
    }
  }, [])
);

// In the timer change handler (wherever the player writes timer duration changes):
// Find the existing handler and add uiStore coupling:
const handleTimerChange = (newDuration: TimerDuration) => {
  useAudioStore.getState().setTimer(newDuration);  // existing line
  useUIStore.getState().setDefaultTimerDuration(newDuration);  // ADD THIS LINE
};
```

IMPORTANT: Before writing the player changes, read `app/player.tsx` and `src/stores/audioStore.ts` to confirm:
1. The exact setter name for the audio timer (setTimer vs setTimerDuration vs other)
2. How the current sound ID is accessed (audioStore.currentSoundId or route params)
3. Where the timer segmented control handler is defined
Then write the changes using the actual names found, not the examples above.
  </action>
  <verify>
    ```bash
    cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds
    # Full TypeScript check
    npx tsc --noEmit 2>&1 | head -30

    # FavoriteButton imported in SoundCard
    grep "FavoriteButton" src/components/SoundCard.tsx

    # FavoriteButton imported in player
    grep "FavoriteButton" app/player.tsx

    # useFocusEffect present in player for timer pre-fill
    grep "useFocusEffect\|defaultTimerDuration" app/player.tsx

    # Timer coupling: setDefaultTimerDuration called in player
    grep "setDefaultTimerDuration" app/player.tsx
    ```
    TypeScript must pass. FavoriteButton must appear in both SoundCard and player. Timer coupling must be present.
  </verify>
  <done>
    - `SoundCard` renders `FavoriteButton` with the current sound's ID — heart visible on every library card
    - `FavoriteButton` positioned without overlapping sound name/subtitle text
    - Player screen renders `FavoriteButton` for the current sound in the controls area
    - `useFocusEffect` in player reads `uiStore.defaultTimerDuration` on focus and writes to `audioStore` if not mid-session
    - Timer change handler in player writes to BOTH `audioStore` and `uiStore.setDefaultTimerDuration` (locked decision honored)
    - No TypeScript errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full plan outcome:

```bash
cd /Users/manuelfrancogiraldez/Documents/2026/proyectos/calm-asmr-sounds
# TypeScript clean across all modified files
npx tsc --noEmit

# FavoriteButton component exists and is valid
grep -n "export function FavoriteButton\|withSequence\|withSpring\|isFavorite(soundId)" src/components/FavoriteButton.tsx

# SoundCard has FavoriteButton
grep -n "FavoriteButton" src/components/SoundCard.tsx

# Player has FavoriteButton + timer coupling
grep -n "FavoriteButton\|defaultTimerDuration\|useFocusEffect" app/player.tsx

# setDefaultTimerDuration called in player timer handler
grep -n "setDefaultTimerDuration" app/player.tsx
```
</verification>

<success_criteria>
- `FavoriteButton` uses scoped selectors (no full store subscription causing mass re-renders)
- Heart icon appears on every SoundCard in the library — filled rose when favorited, outline when not
- Heart icon appears on the player screen controls
- Tapping heart triggers immediate toggle + visible spring pop animation
- Player's `useFocusEffect` pre-fills timer from `uiStore.defaultTimerDuration` when not mid-session
- Every timer change in player writes to BOTH stores (audioStore + uiStore.defaultTimerDuration)
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-favorites/04-02-SUMMARY.md` documenting:
- FavoriteButton: animation parameters, icon names, selector strategy
- SoundCard: where FavoriteButton was placed and why
- Player: how currentSoundId was accessed, exact timer setter name found
- Timer coupling: the two stores written on every timer change
- Any deviations from this plan and why
</output>
